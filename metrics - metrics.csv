영역,구분,지표명,의존지표,설명,코드,,
[0] 기본,설정,라이브러리설정,-,필수 라이브러리 import,"import pandas as pd
import numpy as np
import re
from datetime import datetime, timedelta
import warnings
warnings.filterwarnings('ignore')

def library_setup():
    """"""라이브러리설정""""""
    return {'pandas': pd.__version__, 'numpy': np.__version__, 'status': 'loaded'}

DEFAULT_TABLE_NAME = 'b-flow 주문 내역'
DEFAULT_EXCLUDE_CANCELLED = True
DEFAULT_DATE_FORMAT = '%Y-%m-%d %H:%M:%S'
NUMERIC_PRECISION = 2
CATEGORY_FILE_PATH = 'brich_category_2504071.csv'",,
[0] 기본,설정,기본상수설정,-,전역 상수 정의,"def basic_constants_setup():
    """"""기본상수설정""""""
    return {
        'table_name': DEFAULT_TABLE_NAME,
        'exclude_cancelled': DEFAULT_EXCLUDE_CANCELLED,
        'date_format': DEFAULT_DATE_FORMAT,
        'precision': NUMERIC_PRECISION,
        'category_file': CATEGORY_FILE_PATH
    }

CATEGORY_DF = None",,
[0] 기본,설정,카테고리데이터로드,-,카테고리 CSV 파일 로드,"def load_category_data(file_path=CATEGORY_FILE_PATH):
    """"""카테고리데이터로드""""""
    global CATEGORY_DF
    if CATEGORY_DF is None:
        try:
            CATEGORY_DF = pd.read_csv(file_path)
            CATEGORY_DF = CATEGORY_DF[['Depth', 'Code', 'Name']].copy()
            CATEGORY_DF['Code'] = CATEGORY_DF['Code'].astype(str)
            return {'status': 'loaded', 'rows': len(CATEGORY_DF)}
        except Exception as e:
            return {'status': 'error', 'message': str(e)}
    return {'status': 'already_loaded', 'rows': len(CATEGORY_DF)}",,
[0] 기본,설정,기본필터링,-,업체명/취소주문 기본 필터링,"def basic_filtering(df, company_name=None, exclude_cancelled=DEFAULT_EXCLUDE_CANCELLED):
    """"""기본필터링""""""
    filtered_df = df.copy()
    if company_name is not None:
        if isinstance(company_name, str):
            filtered_df = filtered_df[filtered_df['입점사명'] == company_name]
        elif isinstance(company_name, list):
            filtered_df = filtered_df[filtered_df['입점사명'].isin(company_name)]
    if exclude_cancelled:
        filtered_df = filtered_df[filtered_df['주문상태'] != '결제취소']
    return filtered_df",,
[0] 기본,설정,추가필터적용,-,동적 조건 필터링,"def apply_additional_filter(df, filter_condition=None):
    """"""추가필터적용""""""
    if filter_condition is None:
        return df
    if isinstance(filter_condition, str):
        return df.query(filter_condition)
    elif isinstance(filter_condition, dict):
        filtered_df = df.copy()
        for column, condition in filter_condition.items():
            if isinstance(condition, list):
                filtered_df = filtered_df[filtered_df[column].isin(condition)]
            elif isinstance(condition, tuple) and len(condition) == 2:
                filtered_df = filtered_df[
                    (filtered_df[column] >= condition[0]) & 
                    (filtered_df[column] <= condition[1])
                ]
            else:
                filtered_df = filtered_df[filtered_df[column] == condition]
        return filtered_df
    elif callable(filter_condition):
        return df[filter_condition(df)]
    return df",,
[0] 기본,설정,필터조건빌더,-,복합 조건 생성,"def build_filter_condition(*conditions, operator='and'):
    """"""필터조건빌더""""""
    if not conditions:
        return None
    valid_conditions = [cond for cond in conditions if cond and str(cond).strip()]
    if not valid_conditions:
        return None
    if len(valid_conditions) == 1:
        return str(valid_conditions[0])
    wrapped_conditions = [f""({cond})"" for cond in valid_conditions]
    return ' or '.join(wrapped_conditions) if operator.lower() == 'or' else ' and '.join(wrapped_conditions)",,
[0] 기본,설정,설정정보조회,"기본상수설정, 카테고리데이터로드",현재 설정 상태 확인,"def get_settings_info():
    """"""설정정보조회""""""
    return {
        'basic_settings': basic_constants_setup(),
        'category_data': load_category_data(),
        'library_info': library_setup()
    }",,
[0] 기본,데이터변환,고유구매자생성,-,구매자 고유ID 생성,"def create_unique_buyer(df):
    """"""고유구매자생성""""""
    def extract_phone_last4(phone_str):
        if pd.isna(phone_str):
            return ''
        phone_digits = re.sub(r'[^0-9]', '', str(phone_str))
        return phone_digits[-4:] if len(phone_digits) >= 4 else phone_digits
    
    df = df.copy()
    phone_last4 = df['구매자연락처'].apply(extract_phone_last4)
    df['고유구매자'] = df['구매자명'] + '_' + phone_last4
    return df",,
[0] 기본,데이터변환,중분류명매핑,카테고리데이터로드,카테고리→중분류명 완전 변환,"def map_middle_category_name(df, category_file_path=CATEGORY_FILE_PATH):
    """"""중분류명매핑""""""
    load_result = load_category_data(category_file_path)
    if load_result['status'] == 'error':
        raise Exception(f""카테고리 데이터 로드 실패: {load_result['message']}"")
    
    df = df.copy()
    df['정규카테고리코드'] = (df['상품 카테고리'].astype(str)
                        .str.replace(r'\.0$', '', regex=True)
                        .str.replace(r'\D', '', regex=True))
    
    df['중분류코드'] = df['정규카테고리코드'].apply(lambda x: str(x)[:5] if len(str(x)) >= 5 else str(x))
    
    middle_categories = CATEGORY_DF[CATEGORY_DF['Depth'] == 2].copy()
    middle_mapping = dict(zip(middle_categories['Code'], middle_categories['Name']))
    
    def map_to_middle_name(code):
        if pd.isna(code) or code == '':
            return '기타'
        code_str = str(code)
        if code_str in middle_mapping:
            return middle_mapping[code_str]
        for cat_code, cat_name in middle_mapping.items():
            if code_str.zfill(5) == cat_code.zfill(5):
                return cat_name
        return f'미분류_{code_str}'
    
    df['중분류명'] = df['중분류코드'].apply(map_to_middle_name)
    return df",,
[0] 기본,데이터변환,소분류명매핑,카테고리데이터로드,카테고리→소분류명 완전 변환,"def map_sub_category_name(df, category_file_path=CATEGORY_FILE_PATH):
    """"""소분류명매핑""""""
    load_result = load_category_data(category_file_path)
    if load_result['status'] == 'error':
        raise Exception(f""카테고리 데이터 로드 실패: {load_result['message']}"")
    
    df = df.copy()
    if '정규카테고리코드' not in df.columns:
        df['정규카테고리코드'] = (df['상품 카테고리'].astype(str)
                            .str.replace(r'\.0$', '', regex=True)
                            .str.replace(r'\D', '', regex=True))
    
    def extract_sub_code(code_str):
        code_str = str(code_str)
        if len(code_str) >= 9:
            return code_str[:9]
        elif len(code_str) >= 5:
            return code_str[:5]
        return code_str
    
    df['소분류코드'] = df['정규카테고리코드'].apply(extract_sub_code)
    
    sub_categories = CATEGORY_DF[CATEGORY_DF['Depth'] == 3].copy()
    sub_mapping = dict(zip(sub_categories['Code'], sub_categories['Name']))
    
    def map_to_sub_name(code):
        if pd.isna(code) or code == '':
            return '기타'
        code_str = str(code)
        if code_str in sub_mapping:
            return sub_mapping[code_str]
        for cat_code, cat_name in sub_mapping.items():
            if code_str.zfill(9) == cat_code.zfill(9):
                return cat_name
        
        middle_code = code_str[:5] if len(code_str) >= 5 else code_str
        middle_categories = CATEGORY_DF[CATEGORY_DF['Depth'] == 2]
        middle_mapping = dict(zip(middle_categories['Code'], middle_categories['Name']))
        
        if middle_code in middle_mapping:
            return f""{middle_mapping[middle_code]} (세부미분류)""
        return f'미분류_{code_str}'
    
    df['소분류명'] = df['소분류코드'].apply(map_to_sub_name)
    return df",,
[0] 기본,데이터변환,카테고리분류,카테고리데이터로드,중분류/소분류별 데이터 그룹핑 및 필터링,"def category_classifier(df, category_type='중분류', filter_condition=None):
    """"""카테고리분류 - 중분류/소분류별 데이터 그룹핑""""""
    if filter_condition:
        df = apply_filter(df, filter_condition)
    
    # 카테고리 데이터 로드
    if CATEGORY_DF is None:
        load_category_data()
    
    # 카테고리 매핑
    df_with_category = df.copy()
    
    if category_type == '중분류':
        # 중분류 매핑
        category_mapping = CATEGORY_DF[CATEGORY_DF['Depth'] == 2][['Code', 'Name']].copy()
        category_mapping.columns = ['카테고리코드', '중분류명']
        df_with_category = pd.merge(df_with_category, category_mapping, 
                                  left_on='카테고리', right_on='카테고리코드', how='left')
        return df_with_category.dropna(subset=['중분류명'])
        
    elif category_type == '소분류':
        # 소분류 매핑
        category_mapping = CATEGORY_DF[CATEGORY_DF['Depth'] == 3][['Code', 'Name']].copy()
        category_mapping.columns = ['카테고리코드', '소분류명']
        df_with_category = pd.merge(df_with_category, category_mapping, 
                                  left_on='카테고리', right_on='카테고리코드', how='left')
        return df_with_category.dropna(subset=['소분류명'])
    
    return df_with_category",,
[0] 기본,집계,총매출액,추가필터적용,상품별 총 주문금액 합계,"def total_revenue(df, group_by=None, filter_condition=None):
    """"""총매출액""""""
    filtered_df = apply_additional_filter(df, filter_condition)
    if group_by:
        return filtered_df.groupby(group_by)['상품별 총 주문금액'].sum()
    return filtered_df['상품별 총 주문금액'].sum()",,
[0] 기본,집계,총주문건수,추가필터적용,전체 주문 행 수,"def total_orders(df, group_by=None, filter_condition=None):
    """"""총주문건수""""""
    filtered_df = apply_additional_filter(df, filter_condition)
    if group_by:
        return filtered_df.groupby(group_by).size()
    return len(filtered_df)",,
[0] 기본,집계,성공주문건수,추가필터적용,취소되지 않은 주문건수,"def successful_orders(df, group_by=None, filter_condition=None):
    """"""성공주문건수""""""
    filtered_df = apply_additional_filter(df, filter_condition)
    success_df = filtered_df[filtered_df['주문상태'] != '결제취소']
    if group_by:
        return success_df.groupby(group_by).size()
    return len(success_df)",,
[0] 기본,집계,취소주문건수,추가필터적용,결제취소된 주문건수,"def cancelled_orders(df, group_by=None, filter_condition=None):
    """"""취소주문건수""""""
    filtered_df = apply_additional_filter(df, filter_condition)
    cancel_df = filtered_df[filtered_df['주문상태'] == '결제취소']
    if group_by:
        return cancel_df.groupby(group_by).size()
    return len(cancel_df)",,
[0] 기본,집계,반품주문건수,추가필터적용,반품 상태 주문건수,"def return_orders(df, group_by=None, filter_condition=None):
    """"""반품주문건수""""""
    filtered_df = apply_additional_filter(df, filter_condition)
    return_df = filtered_df[filtered_df['주문상태'] == '반품']
    if group_by:
        return return_df.groupby(group_by).size()
    return len(return_df)",,
[0] 기본,집계,클레임주문건수,추가필터적용,클레임 발생 주문건수,"def claim_orders(df, group_by=None, filter_condition=None):
    """"""클레임주문건수""""""
    filtered_df = apply_additional_filter(df, filter_condition)
    claim_df = filtered_df[filtered_df['클레임'].notna()]
    if group_by:
        return claim_df.groupby(group_by).size()
    return len(claim_df)",,
[0] 기본,집계,총고객수,추가필터적용,구매자명 고유값 수,"def total_customers(df, group_by=None, filter_condition=None):
    """"""총고객수""""""
    filtered_df = apply_additional_filter(df, filter_condition)
    if group_by:
        return filtered_df.groupby(group_by)['구매자명'].nunique()
    return filtered_df['구매자명'].nunique()",,
[0] 기본,집계,총상품수,추가필터적용,상품번호 고유값 수,"def total_products(df, group_by=None, filter_condition=None):
    """"""총상품수""""""
    filtered_df = apply_additional_filter(df, filter_condition)
    if group_by:
        return filtered_df.groupby(group_by)['상품번호'].nunique()
    return filtered_df['상품번호'].nunique()",,
[0] 기본,집계,총수익액,추가필터적용,정산금액 합계,"def total_profit(df, group_by=None, filter_condition=None):
    """"""총수익액""""""
    filtered_df = apply_additional_filter(df, filter_condition)
    if group_by:
        return filtered_df.groupby(group_by)['정산금액'].sum()
    return filtered_df['정산금액'].sum()",,
[0] 기본,집계,총수량,추가필터적용,수량 합계,"def total_quantity(df, group_by=None, filter_condition=None):
    """"""총수량""""""
    filtered_df = apply_additional_filter(df, filter_condition)
    if group_by:
        return filtered_df.groupby(group_by)['수량'].sum()
    return filtered_df['수량'].sum()",,
[0] 기본,평균,평균주문금액,"총매출액, 총주문건수",총매출액 / 총주문건수,"def avg_order_value(df, group_by=None, filter_condition=None):
    """"""평균주문금액""""""
    revenue = total_revenue(df, group_by=group_by, filter_condition=filter_condition)
    orders = total_orders(df, group_by=group_by, filter_condition=filter_condition)
    if group_by:
        return (revenue / orders.replace(0, np.nan)).fillna(0)
    return revenue / orders if orders > 0 else 0",,
[0] 기본,평균,평균상품가격,추가필터적용,상품가격 컬럼 평균값,"def avg_product_price(df, group_by=None, filter_condition=None):
    """"""평균상품가격""""""
    filtered_df = apply_additional_filter(df, filter_condition)
    if group_by:
        return filtered_df.groupby(group_by)['상품가격'].mean()
    return filtered_df['상품가격'].mean()",,
[0] 기본,평균,평균수량,추가필터적용,수량 컬럼 평균값,"def avg_quantity(df, group_by=None, filter_condition=None):
    """"""평균수량""""""
    filtered_df = apply_additional_filter(df, filter_condition)
    if group_by:
        return filtered_df.groupby(group_by)['수량'].mean()
    return filtered_df['수량'].mean()",,
[0] 기본,평균,평균출고시간,추가필터적용,결제일~출고예정일 평균일수,"def avg_shipping_time(df, group_by=None, filter_condition=None):
    """"""평균출고시간""""""
    filtered_df = apply_additional_filter(df, filter_condition)
    valid_df = filtered_df[filtered_df['결제일'].notna() & filtered_df['출고예정일'].notna()].copy()
    if len(valid_df) == 0:
        return 0 if not group_by else pd.Series(dtype=float)
    valid_df['결제일'] = pd.to_datetime(valid_df['결제일'])
    valid_df['출고예정일'] = pd.to_datetime(valid_df['출고예정일'])
    valid_df['출고시간'] = (valid_df['출고예정일'] - valid_df['결제일']).dt.days
    if group_by:
        return valid_df.groupby(group_by)['출고시간'].mean()
    return valid_df['출고시간'].mean()",,
[0] 기본,평균,고유평균값,추가필터적용,분자/분모 컬럼별 평균,"def unique_avg_value(df, numerator_col, denominator_col, group_by=None, filter_condition=None):
    """"""고유평균값""""""
    filtered_df = apply_additional_filter(df, filter_condition)
    valid_df = filtered_df[filtered_df[denominator_col] != 0].copy()
    if len(valid_df) == 0:
        return 0 if not group_by else pd.Series(dtype=float)
    valid_df['비율'] = valid_df[numerator_col] / valid_df[denominator_col]
    if group_by:
        return valid_df.groupby(group_by)['비율'].mean()
    return valid_df['비율'].mean()",,
[0] 기본,비율,취소율,"취소주문건수, 총주문건수",취소주문 / 총주문 비율,"def cancellation_rate(df, group_by=None, filter_condition=None):
    """"""취소율""""""
    cancelled = cancelled_orders(df, group_by=group_by, filter_condition=filter_condition)
    total = total_orders(df, group_by=group_by, filter_condition=filter_condition)
    
    if group_by:
        return (cancelled / total * 100).fillna(0).round(2)
    return round(cancelled / total * 100, 2) if total > 0 else 0",,
[0] 기본,비율,반품률,"반품주문건수, 총주문건수",반품주문 / 총주문 비율,"def return_rate(df, group_by=None, filter_condition=None):
    """"""반품률""""""
    returned = return_orders(df, group_by=group_by, filter_condition=filter_condition)
    total = total_orders(df, group_by=group_by, filter_condition=filter_condition)
    
    if group_by:
        return (returned / total * 100).fillna(0).round(2)
    return round(returned / total * 100, 2) if total > 0 else 0",,
[0] 기본,비율,교환율,"추가필터적용, 총주문건수",교환클레임 / 총주문 비율,"def exchange_rate(df, group_by=None, filter_condition=None):
    """"""교환율""""""
    filtered_df = apply_additional_filter(df, filter_condition)
    exchange_df = filtered_df[filtered_df['클레임'].str.contains('교환', na=False)]
    
    exchanged = total_orders(exchange_df, group_by=group_by)
    total = total_orders(filtered_df, group_by=group_by)
    
    if group_by:
        return (exchanged / total * 100).fillna(0).round(2)
    return round(exchanged / total * 100, 2) if total > 0 else 0",,
[0] 기본,비율,배송성공률,"성공주문건수, 총주문건수",성공주문 / 총주문 비율,"def delivery_success_rate(df, group_by=None, filter_condition=None):
    """"""배송성공률""""""
    success = successful_orders(df, group_by=group_by, filter_condition=filter_condition)
    total = total_orders(df, group_by=group_by, filter_condition=filter_condition)
    
    if group_by:
        return (success / total * 100).fillna(0).round(2)
    return round(success / total * 100, 2) if total > 0 else 0",,
[0] 기본,비율,클레임률,"클레임주문건수, 총주문건수",클레임주문 / 총주문 비율,"def claim_rate(df, group_by=None, filter_condition=None):
    """"""클레임률""""""
    claims = claim_orders(df, group_by=group_by, filter_condition=filter_condition)
    total = total_orders(df, group_by=group_by, filter_condition=filter_condition)
    
    if group_by:
        return (claims / total * 100).fillna(0).round(2)
    return round(claims / total * 100, 2) if total > 0 else 0",,
[0] 기본,비율,당일발송률,"추가필터적용, 총주문건수",당일발송 / 총주문 비율,"def same_day_shipping_rate(df, group_by=None, filter_condition=None):
    """"""당일발송률""""""
    filtered_df = apply_additional_filter(df, filter_condition)
    valid_df = filtered_df[filtered_df['결제일'].notna() & filtered_df['출고예정일'].notna()].copy()
    
    if len(valid_df) == 0:
        return 0 if not group_by else pd.Series(dtype=float)
    
    valid_df['결제일'] = pd.to_datetime(valid_df['결제일']).dt.date
    valid_df['출고예정일'] = pd.to_datetime(valid_df['출고예정일']).dt.date
    same_day_df = valid_df[valid_df['결제일'] == valid_df['출고예정일']]
    
    same_day = total_orders(same_day_df, group_by=group_by)
    total = total_orders(valid_df, group_by=group_by)
    
    if group_by:
        return (same_day / total * 100).fillna(0).round(2)
    return round(same_day / total * 100, 2) if total > 0 else 0",,
[0] 기본,비율,배송지연률,"추가필터적용, 총주문건수",지연발송 / 총주문 비율,"def delivery_delay_rate(df, group_by=None, filter_condition=None):
    """"""배송지연률""""""
    filtered_df = apply_additional_filter(df, filter_condition)
    valid_df = filtered_df[filtered_df['결제일'].notna() & filtered_df['출고예정일'].notna()].copy()
    
    if len(valid_df) == 0:
        return 0 if not group_by else pd.Series(dtype=float)
    
    valid_df['결제일'] = pd.to_datetime(valid_df['결제일'])
    valid_df['출고예정일'] = pd.to_datetime(valid_df['출고예정일'])
    valid_df['지연일수'] = (valid_df['출고예정일'] - valid_df['결제일']).dt.days
    delayed_df = valid_df[valid_df['지연일수'] > 1]
    
    delayed = total_orders(delayed_df, group_by=group_by)
    total = total_orders(valid_df, group_by=group_by)
    
    if group_by:
        return (delayed / total * 100).fillna(0).round(2)
    return round(delayed / total * 100, 2) if total > 0 else 0",,
[0] 기본,비율,수익률,"총수익액, 총매출액",총수익액 / 총매출액 비율,"def profit_rate(df, group_by=None, filter_condition=None):
    """"""수익률""""""
    profit = total_profit(df, group_by=group_by, filter_condition=filter_condition)
    revenue = total_revenue(df, group_by=group_by, filter_condition=filter_condition)
    
    if group_by:
        return (profit / revenue * 100).fillna(0).round(2)
    return round(profit / revenue * 100, 2) if revenue > 0 else 0",,
[0] 기본,비율,할인율,추가필터적용,할인금액 / 상품가격 비율,"def discount_rate(df, group_by=None, filter_condition=None):
    """"""할인율""""""
    filtered_df = apply_additional_filter(df, filter_condition)
    valid_df = filtered_df[filtered_df['상품가격'] > 0].copy()
    
    if len(valid_df) == 0:
        return 0 if not group_by else pd.Series(dtype=float)
    
    if group_by:
        grouped = valid_df.groupby(group_by)
        discount_sum = grouped['판매자 부담 할인액'].sum()
        price_sum = grouped['상품가격'].sum()
        return (discount_sum / price_sum * 100).fillna(0).round(2)
    
    discount_sum = valid_df['판매자 부담 할인액'].sum()
    price_sum = valid_df['상품가격'].sum()
    return round(discount_sum / price_sum * 100, 2) if price_sum > 0 else 0",,
[0] 기본,비율,옵션비율,추가필터적용,옵션가격 / 상품가격 비율,"def option_rate(df, group_by=None, filter_condition=None):
    """"""옵션비율""""""
    filtered_df = apply_additional_filter(df, filter_condition)
    valid_df = filtered_df[filtered_df['상품가격'] > 0].copy()
    
    if len(valid_df) == 0:
        return 0 if not group_by else pd.Series(dtype=float)
    
    if group_by:
        grouped = valid_df.groupby(group_by)
        option_sum = grouped['옵션가격'].sum()
        price_sum = grouped['상품가격'].sum()
        return (option_sum / price_sum * 100).fillna(0).round(2)
    
    option_sum = valid_df['옵션가격'].sum()
    price_sum = valid_df['상품가격'].sum()
    return round(option_sum / price_sum * 100, 2) if price_sum > 0 else 0",,
[0] 기본,비율,재구매율,추가필터적용,재구매고객 / 전체고객 비율,"def repurchase_rate(df, group_by=None, filter_condition=None):
    """"""재구매율""""""
    filtered_df = apply_additional_filter(df, filter_condition)
    
    if group_by:
        # 그룹별 재구매율 계산은 복잡하므로 단순화
        grouped = filtered_df.groupby(group_by)
        results = {}
        for name, group in grouped:
            customer_orders = group.groupby('구매자명').size()
            repeat_customers = len(customer_orders[customer_orders >= 2])
            total_customers = len(customer_orders)
            results[name] = round(repeat_customers / total_customers * 100, 2) if total_customers > 0 else 0
        return pd.Series(results)
    
    # 고객별 주문 건수 계산
    customer_orders = filtered_df.groupby('구매자명').size()
    repeat_customers = len(customer_orders[customer_orders >= 2])
    total_customers = len(customer_orders)
    
    return round(repeat_customers / total_customers * 100, 2) if total_customers > 0 else 0",,
[0] 기본,비율,기여도,추가필터적용,부분/전체 기여도 백분율 계산 (group_by 지원),"def contribution_calculator(df, metric_column, group_by=None, filter_condition=None):
    """"""기여도 - 부분/전체 기여도 백분율 계산""""""
    if filter_condition:
        df = apply_filter(df, filter_condition)
    
    if group_by:
        group_sum = df.groupby(group_by)[metric_column].sum().reset_index()
        total_sum = df[metric_column].sum()
        group_sum['기여도(%)'] = (group_sum[metric_column] / total_sum * 100).round(2)
        group_sum['누적기여도(%)'] = group_sum['기여도(%)'].cumsum().round(2)
        return group_sum.sort_values(metric_column, ascending=False)
    else:
        return df[metric_column].sum()",,
[0] 기본,비율,점유율,추가필터적용,각 그룹의 전체 대비 점유율 계산,"def market_share_calculator(df, metric_column, group_by, filter_condition=None):
    """"""점유율 - 각 그룹의 전체 대비 점유율 계산""""""
    if filter_condition:
        df = apply_filter(df, filter_condition)
    
    group_sum = df.groupby(group_by)[metric_column].sum().reset_index()
    total_sum = group_sum[metric_column].sum()
    group_sum['점유율(%)'] = (group_sum[metric_column] / total_sum * 100).round(2)
    
    return group_sum.sort_values('점유율(%)', ascending=False)",,
[0] 기본,비율,지표결합,추가필터적용,여러 지표를 결합하여 새로운 지표 생성,"def metric_combiner(df, combine_config, group_by=None, filter_condition=None):
    """"""지표결합계산 - 여러 지표를 결합하여 새로운 지표 생성""""""
    if filter_condition:
        df = apply_filter(df, filter_condition)
    
    operation = combine_config.get('operation', 'add')
    columns = combine_config.get('columns', [])
    
    if group_by:
        grouped = df.groupby(group_by)
        
        if operation == 'add':
            result = grouped[columns].sum().sum(axis=1).reset_index(name='결합지표')
        elif operation == 'divide':
            numerator_col, denominator_col = columns[0], columns[1]
            result = (grouped[numerator_col].sum() / grouped[denominator_col].sum() * 100).round(2).reset_index(name='결합지표')
        
        return result
    else:
        if operation == 'add':
            return df[columns].sum(axis=1)
        elif operation == 'divide':
            return (df[columns[0]] / df[columns[1]] * 100).round(2)",,
[0] 기본,고급,상품집중도,총매출액,상위 N개 상품의 매출 집중도,"def product_concentration(df, group_by=None, filter_condition=None, top_n=10):
    """"""상품집중도""""""
    if group_by:
        results = {}
        for name, group in df.groupby(group_by):
            product_revenue = total_revenue(group, group_by='상품명', filter_condition=filter_condition)
            total_rev = product_revenue.sum()
            if total_rev > 0:
                top_revenue = product_revenue.nlargest(top_n).sum()
                concentration = round(top_revenue / total_rev * 100, 2)
            else:
                concentration = 0
            results[name] = concentration
        return pd.Series(results)
    
    product_revenue = total_revenue(df, group_by='상품명', filter_condition=filter_condition)
    total_rev = product_revenue.sum()
    
    if total_rev == 0:
        return 0
    
    top_revenue = product_revenue.nlargest(top_n).sum()
    return round(top_revenue / total_rev * 100, 2)",,
[0] 기본,고급,시장점유율,총매출액,특정 시장 내 점유율,"def market_share(df, market_column, group_by=None, filter_condition=None):
    """"""시장점유율""""""
    if group_by:
        results = {}
        for name, group in df.groupby(group_by):
            group_revenue = total_revenue(group, filter_condition=filter_condition)
            market_revenue = total_revenue(df, group_by=market_column, filter_condition=filter_condition)
            market_name = group[market_column].iloc[0] if len(group) > 0 else None
            if market_name and market_name in market_revenue:
                market_total = market_revenue[market_name]
                share = round(group_revenue / market_total * 100, 2) if market_total > 0 else 0
            else:
                share = 0
            results[name] = share
        return pd.Series(results)
    
    my_revenue = total_revenue(df, filter_condition=filter_condition)
    total_market = total_revenue(df, group_by=market_column, filter_condition=filter_condition).sum()
    
    return round(my_revenue / total_market * 100, 2) if total_market > 0 else 0",,
[0] 기본,고급,매출성장률,총매출액,기간별 매출 증가율,"def revenue_growth_rate(df, date_column='결제일', group_by=None, filter_condition=None, period='M'):
    """"""매출성장률""""""
    filtered_df = apply_additional_filter(df, filter_condition)
    valid_df = filtered_df[filtered_df[date_column].notna()].copy()
    
    if len(valid_df) == 0:
        return 0 if not group_by else pd.Series(dtype=float)
    
    valid_df[date_column] = pd.to_datetime(valid_df[date_column])
    valid_df['period'] = valid_df[date_column].dt.to_period(period)
    
    if group_by:
        results = {}
        for name, group in valid_df.groupby(group_by):
            period_revenue = total_revenue(group, group_by='period')
            if len(period_revenue) < 2:
                growth_rate = 0
            else:
                period_revenue = period_revenue.sort_index()
                latest = period_revenue.iloc[-1]
                previous = period_revenue.iloc[-2]
                growth_rate = round((latest - previous) / previous * 100, 2) if previous > 0 else 0
            results[name] = growth_rate
        return pd.Series(results)
    
    period_revenue = total_revenue(valid_df, group_by='period')
    if len(period_revenue) < 2:
        return 0
    
    period_revenue = period_revenue.sort_index()
    latest = period_revenue.iloc[-1]
    previous = period_revenue.iloc[-2]
    
    return round((latest - previous) / previous * 100, 2) if previous > 0 else 0",,
[0] 기본,고급,다양성지수,추가필터적용,Shannon 다양성 지수,"def diversity_index(df, diversity_column, group_by=None, filter_condition=None):
    """"""다양성""""""
    filtered_df = apply_additional_filter(df, filter_condition)
    
    if group_by:
        results = {}
        for name, group in filtered_df.groupby(group_by):
            # Shannon 다양성 지수 계산
            value_counts = group[diversity_column].value_counts()
            if len(value_counts) == 0:
                diversity = 0
            elif len(value_counts) == 1:
                diversity = 0
            else:
                total = value_counts.sum()
                proportions = value_counts / total
                shannon_index = -sum(p * np.log(p) for p in proportions if p > 0)
                # 정규화 (0-100 스케일)
                max_diversity = np.log(len(value_counts))
                diversity = round(shannon_index / max_diversity * 100, 2) if max_diversity > 0 else 0
            
            results[name] = diversity
        return pd.Series(results)
    
    # Shannon 다양성 지수 계산
    value_counts = filtered_df[diversity_column].value_counts()
    
    if len(value_counts) <= 1:
        return 0
    
    total = value_counts.sum()
    proportions = value_counts / total
    shannon_index = -sum(p * np.log(p) for p in proportions if p > 0)
    
    # 정규화 (0-100 스케일)
    max_diversity = np.log(len(value_counts))
    return round(shannon_index / max_diversity * 100, 2) if max_diversity > 0 else 0",,
[0] 기본,고급,변동률,추가필터적용,두 기간 데이터 비교하여 변동률 계산,"def change_analyzer(current_df, previous_df, metric_column, group_by=None, filter_condition=None):
    """"""변동분석 - 두 기간 데이터 비교하여 변동률 계산""""""
    if filter_condition:
        current_df = apply_filter(current_df, filter_condition)
        previous_df = apply_filter(previous_df, filter_condition)
    
    if group_by:
        current = current_df.groupby(group_by)[metric_column].sum().reset_index()
        previous = previous_df.groupby(group_by)[metric_column].sum().reset_index()
        
        comparison = pd.merge(current, previous, on=group_by, suffixes=['_현재', '_이전'], how='outer').fillna(0)
        
        comparison['변동률(%)'] = comparison.apply(
            lambda row: 100.0 if row[f'{metric_column}_이전'] == 0 and row[f'{metric_column}_현재'] > 0
            else 0.0 if row[f'{metric_column}_이전'] == 0
            else ((row[f'{metric_column}_현재'] - row[f'{metric_column}_이전']) / row[f'{metric_column}_이전'] * 100),
            axis=1
        ).round(2)
        
        comparison['변동량'] = (comparison[f'{metric_column}_현재'] - comparison[f'{metric_column}_이전']).round(2)
        
        return comparison.sort_values('변동률(%)', ascending=False)
    else:
        current_total = current_df[metric_column].sum()
        previous_total = previous_df[metric_column].sum()
        
        if previous_total == 0:
            return 100.0 if current_total > 0 else 0.0
        
        return ((current_total - previous_total) / previous_total * 100).round(2)",,
[0] 기본,고급,분포,추가필터적용,연속형 데이터의 구간별 분포 계산,"def distribution_analyzer(df, value_column, bins=5, labels=None, group_by=None, filter_condition=None):
    """"""분포분석 - 연속형 데이터의 구간별 분포 계산""""""
    if filter_condition:
        df = apply_filter(df, filter_condition)
    
    df_copy = df.copy()
    
    if labels is None:
        df_copy['구간'] = pd.cut(df_copy[value_column], bins=bins)
    else:
        df_copy['구간'] = pd.cut(df_copy[value_column], bins=bins, labels=labels)
    
    if group_by:
        result = df_copy.groupby([group_by, '구간']).size().reset_index(name='건수')
        result['비율(%)'] = result.groupby(group_by)['건수'].transform(lambda x: (x / x.sum() * 100).round(2))
        return result
    else:
        result = df_copy.groupby('구간').agg({
            value_column: ['count', 'sum', 'mean']
        }).reset_index()
        result.columns = ['구간', '건수', '합계', '평균']
        result['비율(%)'] = (result['건수'] / result['건수'].sum() * 100).round(2)
        return result",,
[0] 기본,고급,추세,추가필터적용,시계열 데이터의 추세 및 트렌드 분석,"def trend_analyzer(df_list, metric_column, group_by=None, filter_condition=None):
    """"""추세분석 - 시계열 데이터의 추세 및 트렌드 분석""""""
    analyzed_data = []
    
    for i, df in enumerate(df_list):
        if filter_condition:
            df = apply_filter(df, filter_condition)
        
        if group_by:
            period_data = df.groupby(group_by)[metric_column].sum().reset_index()
        else:
            period_data = pd.DataFrame({metric_column: [df[metric_column].sum()]})
        
        period_data['기간'] = i + 1
        analyzed_data.append(period_data)
    
    # 전체 트렌드 데이터 결합
    trend_data = pd.concat(analyzed_data, ignore_index=True)
    
    if group_by:
        # 그룹별 트렌드 계산
        trend_result = []
        for group in trend_data[group_by].unique():
            group_data = trend_data[trend_data[group_by] == group].sort_values('기간')
            
            # 단순 선형 추세 계산 (기울기)
            x = group_data['기간'].values
            y = group_data[metric_column].values
            
            if len(x) > 1:
                slope = np.polyfit(x, y, 1)[0]
                trend_direction = '증가' if slope > 0 else '감소' if slope < 0 else '횡보'
            else:
                slope = 0
                trend_direction = '데이터부족'
            
            trend_result.append({
                group_by: group,
                '추세기울기': round(slope, 2),
                '추세방향': trend_direction,
                '시작값': y[0] if len(y) > 0 else 0,
                '종료값': y[-1] if len(y) > 0 else 0
            })
        
        return pd.DataFrame(trend_result)
    else:
        # 전체 트렌드만 계산
        x = trend_data['기간'].values
        y = trend_data[metric_column].values
        slope = np.polyfit(x, y, 1)[0]
        
        return {
            '추세기울기': round(slope, 2),
            '추세방향': '증가' if slope > 0 else '감소' if slope < 0 else '횡보'
        }",,
[0] 기본,고급,이탈률,추가필터적용,고객/업체 등의 이탈률 및 이탈 패턴 분석,"def churn_analyzer(df, customer_id_column, date_column, churn_days=90, filter_condition=None):
    """"""이탈분석 - 고객/업체 등의 이탈률 및 이탈 패턴 분석""""""
    if filter_condition:
        df = apply_filter(df, filter_condition)
    
    # 최근 구매일 계산
    df[date_column] = pd.to_datetime(df[date_column])
    latest_purchase = df.groupby(customer_id_column)[date_column].max().reset_index()
    latest_purchase.columns = [customer_id_column, '최근구매일']
    
    # 기준일 (분석 시점)
    analysis_date = df[date_column].max()
    
    # 이탈 여부 판단
    latest_purchase['경과일수'] = (analysis_date - latest_purchase['최근구매일']).dt.days
    latest_purchase['이탈여부'] = latest_purchase['경과일수'] > churn_days
    
    # 이탈률 계산
    total_customers = len(latest_purchase)
    churned_customers = latest_purchase['이탈여부'].sum()
    churn_rate = (churned_customers / total_customers * 100).round(2)
    
    result = {
        '전체고객수': total_customers,
        '이탈고객수': churned_customers,
        '이탈률(%)': churn_rate,
        '이탈고객목록': latest_purchase[latest_purchase['이탈여부']][customer_id_column].tolist()
    }
    
    return result",,
[0] 기본,고급,LTV,추가필터적용,고객 생애가치(Customer Lifetime Value) 계산,"def ltv_calculator(df, customer_id_column, revenue_column, date_column, filter_condition=None):
    """"""LTV계산 - 고객 생애가치(Customer Lifetime Value) 계산""""""
    if filter_condition:
        df = apply_filter(df, filter_condition)
    
    # 고객별 구매 정보 집계
    customer_summary = df.groupby(customer_id_column).agg({
        revenue_column: ['sum', 'mean', 'count'],
        date_column: ['min', 'max']
    }).reset_index()
    
    # 컬럼명 정리
    customer_summary.columns = [
        customer_id_column, '총구매금액', '평균구매금액', '구매횟수', '첫구매일', '최근구매일'
    ]
    
    # 구매 기간 계산
    customer_summary['첫구매일'] = pd.to_datetime(customer_summary['첫구매일'])
    customer_summary['최근구매일'] = pd.to_datetime(customer_summary['최근구매일'])
    customer_summary['구매기간(일)'] = (customer_summary['최근구매일'] - customer_summary['첫구매일']).dt.days
    
    # 구매 주기 계산 (0으로 나누기 방지)
    customer_summary['구매주기(일)'] = customer_summary.apply(
        lambda row: row['구매기간(일)'] / (row['구매횟수'] - 1) if row['구매횟수'] > 1 else 0,
        axis=1
    ).round(1)
    
    # 예상 생애가치 계산 (단순 모델: 평균구매금액 * 예상 총 구매횟수)
    # 예상 총 구매횟수 = (예상 고객 생애기간 / 구매주기)
    expected_lifetime_days = 365 * 2  # 2년으로 가정
    
    customer_summary['예상LTV'] = customer_summary.apply(
        lambda row: row['평균구매금액'] * (expected_lifetime_days / row['구매주기(일)']) 
        if row['구매주기(일)'] > 0 else row['총구매금액'],
        axis=1
    ).round(0)
    
    # 현재까지의 실제 LTV (총구매금액)
    customer_summary['현재LTV'] = customer_summary['총구매금액']
    
    return customer_summary.sort_values('예상LTV', ascending=False)",,
[0] 기본,고급,다중조건비율,추가필터적용,복합적인 조건을 만족하는 데이터 비율 계산,"def multi_condition_calculator(df, conditions_config, group_by=None, filter_condition=None):
    """"""다중조건계산 - 복합적인 조건을 만족하는 데이터 비율 계산""""""
    if filter_condition:
        df = apply_filter(df, filter_condition)
    
    # conditions_config 예시:
    # {
    #   'conditions': [
    #       {'column': '상품수', 'operator': '>=', 'value': 2},
    #       {'column': '구매금액', 'operator': '>', 'value': 100000}
    #   ],
    #   'logic': 'AND'  # 'AND' 또는 'OR'
    # }
    
    conditions = conditions_config.get('conditions', [])
    logic = conditions_config.get('logic', 'AND')
    
    # 각 조건별 마스크 생성
    condition_masks = []
    
    for condition in conditions:
        column = condition['column']
        operator = condition['operator']
        value = condition['value']
        
        if operator == '>=':
            mask = df[column] >= value
        elif operator == '>':
            mask = df[column] > value
        elif operator == '<=':
            mask = df[column] <= value
        elif operator == '<':
            mask = df[column] < value
        elif operator == '==':
            mask = df[column] == value
        elif operator == '!=':
            mask = df[column] != value
        else:
            mask = pd.Series([True] * len(df))
        
        condition_masks.append(mask)
    
    # 조건들을 논리연산으로 결합
    if logic == 'AND':
        final_mask = condition_masks[0]
        for mask in condition_masks[1:]:
            final_mask = final_mask & mask
    else:  # OR
        final_mask = condition_masks[0]
        for mask in condition_masks[1:]:
            final_mask = final_mask | mask
    
    if group_by:
        # 그룹별 다중조건 만족 비율 계산
        result = df.groupby(group_by).agg({
            df.columns[0]: 'count'  # 전체 건수
        }).reset_index()
        result.columns = [group_by, '전체건수']
        
        # 조건 만족 건수
        condition_met = df[final_mask].groupby(group_by).size().reset_index(name='조건만족건수')
        
        # 결과 병합
        result = pd.merge(result, condition_met, on=group_by, how='left').fillna(0)
        result['조건만족비율(%)'] = (result['조건만족건수'] / result['전체건수'] * 100).round(2)
        
        return result.sort_values('조건만족비율(%)', ascending=False)
    else:
        # 전체 데이터에 대한 조건 만족 비율
        total_count = len(df)
        condition_met_count = final_mask.sum()
        condition_rate = (condition_met_count / total_count * 100).round(2)
        
        return {
            '전체건수': total_count,
            '조건만족건수': condition_met_count,
            '조건만족비율(%)': condition_rate
        }",,
[0] 기본,고급,시계열추이,추가필터적용,일자별/주차별/월별 시계열 데이터 추이 분석,"def time_series_trend(df, date_column, metric_column, period_type='daily', group_by=None, filter_condition=None):
    """"""시계열추이 - 일자별/주차별/월별 시계열 데이터 추이 분석""""""
    if filter_condition:
        df = apply_filter(df, filter_condition)
    
    # 날짜 컬럼 변환
    df[date_column] = pd.to_datetime(df[date_column])
    df_copy = df.copy()
    
    # 기간별 그룹핑
    if period_type == 'daily':
        df_copy['기간'] = df_copy[date_column].dt.date
    elif period_type == 'weekly':
        df_copy['기간'] = df_copy[date_column].dt.to_period('W').astype(str)
    elif period_type == 'monthly':
        df_copy['기간'] = df_copy[date_column].dt.to_period('M').astype(str)
    elif period_type == 'hourly':
        df_copy['기간'] = df_copy[date_column].dt.hour
    elif period_type == 'weekday':
        df_copy['기간'] = df_copy[date_column].dt.day_name()
    
    # 그룹별 집계
    if group_by:
        result = df_copy.groupby(['기간', group_by])[metric_column].sum().reset_index()
        result = result.pivot(index='기간', columns=group_by, values=metric_column).fillna(0)
    else:
        result = df_copy.groupby('기간')[metric_column].sum().reset_index()
    
    return result.sort_values('기간')",,
[0] 기본,고급,패턴분석,추가필터적용,시간대별/요일별 등 주기적 패턴 분석,"def pattern_analyzer(df, date_column, metric_column, pattern_type='hourly', filter_condition=None):
    """"""패턴분석 - 시간대별/요일별 등 주기적 패턴 분석""""""
    if filter_condition:
        df = apply_filter(df, filter_condition)
    
    # 날짜 컬럼 변환
    df[date_column] = pd.to_datetime(df[date_column])
    df_copy = df.copy()
    
    if pattern_type == 'hourly':
        # 시간대별 패턴
        df_copy['시간대'] = df_copy[date_column].dt.hour
        pattern_data = df_copy.groupby('시간대')[metric_column].agg(['sum', 'mean', 'count']).reset_index()
        
    elif pattern_type == 'weekday':
        # 요일별 패턴
        df_copy['요일'] = df_copy[date_column].dt.day_name()
        weekday_order = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
        df_copy['요일'] = pd.Categorical(df_copy['요일'], categories=weekday_order, ordered=True)
        pattern_data = df_copy.groupby('요일')[metric_column].agg(['sum', 'mean', 'count']).reset_index()
        
    elif pattern_type == 'monthly':
        # 월별 패턴
        df_copy['월'] = df_copy[date_column].dt.month
        pattern_data = df_copy.groupby('월')[metric_column].agg(['sum', 'mean', 'count']).reset_index()
    
    # 패턴 강도 계산 (변동계수)
    pattern_data.columns = [pattern_data.columns[0], '합계', '평균', '건수']
    pattern_data['패턴강도'] = (pattern_data['평균'].std() / pattern_data['평균'].mean() * 100).round(2)
    
    return pattern_data",,
[0] 기본,고급,피크검출,추가필터적용,데이터에서 최고점/최저점 시점 검출,"def peak_detector(df, metric_column, peak_type='max', top_n=3, filter_condition=None):
    """"""피크검출 - 데이터에서 최고점/최저점 시점 검출""""""
    if filter_condition:
        df = apply_filter(df, filter_condition)
    
    df_sorted = df.copy()
    
    if peak_type == 'max':
        # 최고점 검출
        df_sorted = df_sorted.sort_values(metric_column, ascending=False)
    elif peak_type == 'min':
        # 최저점 검출
        df_sorted = df_sorted.sort_values(metric_column, ascending=True)
    
    # 상위 N개 피크 추출
    peaks = df_sorted.head(top_n).copy()
    
    # 피크 정보 추가
    peaks['피크순위'] = range(1, len(peaks) + 1)
    peaks['피크타입'] = peak_type
    
    return peaks",,
[0] 기본,고급,스코어계산,추가필터적용,패턴 강도나 품질을 수치화한 스코어 계산,"def score_calculator(df, score_config, filter_condition=None):
    """"""스코어계산 - 패턴 강도나 품질을 수치화한 스코어 계산""""""
    if filter_condition:
        df = apply_filter(df, filter_condition)
    
    # score_config 예시:
    # {
    #   'type': 'pattern_strength',  # 패턴 강도 스코어
    #   'metric_column': '매출액',
    #   'group_column': '시간대',
    #   'weight_factors': {'consistency': 0.4, 'magnitude': 0.6}
    # }
    
    score_type = score_config.get('type', 'pattern_strength')
    metric_column = score_config.get('metric_column')
    group_column = score_config.get('group_column')
    
    if score_type == 'pattern_strength':
        # 패턴 강도 스코어 계산
        grouped_data = df.groupby(group_column)[metric_column].agg(['mean', 'std', 'count']).reset_index()
        
        # 일관성 점수 (변동계수의 역수)
        consistency_score = 1 / (grouped_data['std'] / grouped_data['mean'] + 0.01) * 10
        
        # 크기 점수 (평균값 정규화)
        magnitude_score = (grouped_data['mean'] / grouped_data['mean'].max()) * 100
        
        # 가중평균 스코어
        weights = score_config.get('weight_factors', {'consistency': 0.5, 'magnitude': 0.5})
        total_score = (consistency_score * weights['consistency'] + 
                      magnitude_score * weights['magnitude']).round(2)
        
        grouped_data['일관성점수'] = consistency_score.round(2)
        grouped_data['크기점수'] = magnitude_score.round(2)
        grouped_data['종합점수'] = total_score
        
        return grouped_data.sort_values('종합점수', ascending=False)
    
    elif score_type == 'quality_score':
        # 품질 스코어 계산 (예: 에러율 기반)
        total_count = len(df)
        error_conditions = score_config.get('error_conditions', [])
        
        error_count = 0
        for condition in error_conditions:
            error_count += len(df[df[condition['column']].apply(condition['check_function'])])
        
        quality_score = ((total_count - error_count) / total_count * 100).round(2)
        
        return {
            '전체건수': total_count,
            '에러건수': error_count,
            '품질점수': quality_score
        }
    
    return df",,
[0] 기본,순위,매출순위,총매출액,매출액 기준 순위,"def revenue_ranking(df, group_by, filter_condition=None, ascending=False):
    """"""매출순위""""""
    revenue_data = total_revenue(df, group_by=group_by, filter_condition=filter_condition)
    ranking = revenue_data.rank(method='min', ascending=ascending).astype(int)
    
    result_df = pd.DataFrame({
        group_by: revenue_data.index,
        '매출액': revenue_data.values,
        '순위': ranking.values
    }).sort_values('순위')
    
    return result_df",,
[0] 기본,순위,주문량순위,총주문건수,주문건수 기준 순위,"def order_volume_ranking(df, group_by, filter_condition=None, ascending=False):
    """"""주문량순위""""""
    order_data = total_orders(df, group_by=group_by, filter_condition=filter_condition)
    ranking = order_data.rank(method='min', ascending=ascending).astype(int)
    
    result_df = pd.DataFrame({
        group_by: order_data.index,
        '주문건수': order_data.values,
        '순위': ranking.values
    }).sort_values('순위')
    
    return result_df",,
[0] 기본,순위,수익성순위,총수익액,수익액 기준 순위,"def profitability_ranking(df, group_by, filter_condition=None, ascending=False):
    """"""수익성순위""""""
    profit_data = total_profit(df, group_by=group_by, filter_condition=filter_condition)
    ranking = profit_data.rank(method='min', ascending=ascending).astype(int)
    
    result_df = pd.DataFrame({
        group_by: profit_data.index,
        '수익액': profit_data.values,
        '순위': ranking.values
    }).sort_values('순위')
    
    return result_df",,
[0] 기본,순위,AOV순위,평균주문금액,평균주문금액 기준 순위,"def aov_ranking(df, group_by, filter_condition=None, ascending=False):
    """"""AOV순위""""""
    aov_data = avg_order_value(df, group_by=group_by, filter_condition=filter_condition)
    ranking = aov_data.rank(method='min', ascending=ascending).astype(int)
    
    result_df = pd.DataFrame({
        group_by: aov_data.index,
        'AOV': aov_data.values,
        '순위': ranking.values
    }).sort_values('순위')
    
    return result_df",,
[0] 기본,순위,성장률순위,매출성장률,매출성장률 기준 순위,"def growth_rate_ranking(df, group_by, filter_condition=None, ascending=False, date_column='결제일', period='M'):
    """"""성장률순위""""""
    growth_data = revenue_growth_rate(df, date_column=date_column, group_by=group_by, filter_condition=filter_condition, period=period)
    ranking = growth_data.rank(method='min', ascending=ascending).astype(int)
    
    result_df = pd.DataFrame({
        group_by: growth_data.index,
        '성장률': growth_data.values,
        '순위': ranking.values
    }).sort_values('순위')
    
    return result_df",,
[0] 기본,순위,순위,추가필터적용,지정된 컬럼 기준으로 순위 계산 (group_by 지원),"def ranking_calculator(df, rank_column, group_by=None, ascending=False, filter_condition=None):
    """"""순위 - 지정된 컬럼 기준으로 순위 매기기""""""
    if filter_condition:
        df = apply_filter(df, filter_condition)
    
    if group_by:
        result = df.groupby(group_by)[rank_column].sum().reset_index()
        result = result.sort_values(rank_column, ascending=ascending)
        result['순위'] = result[rank_column].rank(ascending=ascending, method='dense')
        return result
    else:
        df_copy = df.copy()
        df_copy['순위'] = df_copy[rank_column].rank(ascending=ascending, method='dense')
        return df_copy.sort_values(rank_column, ascending=ascending)",,
[0] 기본,순위,상위N개,-,정렬된 데이터에서 상위 N개 행 추출,"def top_n_extractor(df, n=30):
    """"""상위N개추출 - 정렬된 데이터에서 상위 N개 행 추출""""""
    return df.head(n)",,
[1] 상품,순위,상품별매출순위,"총매출액, 순위계산, 상위N개추출",상품별 매출액을 계산하고 순위를 매겨 상위 30개 추출,"def product_revenue_ranking(df, filter_condition=None):
    """"""상품별매출순위""""""
    # 1. 상품별 매출액 계산
    revenue_data = total_revenue(df, group_by='상품명', filter_condition=filter_condition)
    
    # 2. 순위 계산
    ranked_data = ranking_calculator(revenue_data, '매출액')
    
    # 3. 상위 30개 추출
    return top_n_extractor(ranked_data, n=30)",,
[1] 상품,순위,상품별주문수순위,"총주문건수, 순위계산, 상위N개추출",상품별 주문건수를 계산하고 순위를 매겨 상위 30개 추출,"def product_order_ranking(df, filter_condition=None):
    """"""상품별주문수순위""""""
    # 1. 상품별 주문건수 계산
    order_data = total_orders(df, group_by='상품명', filter_condition=filter_condition)
    
    # 2. 순위 계산
    ranked_data = ranking_calculator(order_data, '주문건수')
    
    # 3. 상위 30개 추출
    return top_n_extractor(ranked_data, n=30)",,
[1] 상품,고급,히트상품기여도,"총매출액, 기여도계산, 상위N개추출",상품별 매출 기여도를 계산하여 상위 20개 히트상품 식별,"def hit_product_contribution(df, filter_condition=None):
    """"""히트상품기여도""""""
    # 1. 상품별 매출 기여도 계산
    contribution_data = contribution_calculator(df, '매출액', group_by='상품명', filter_condition=filter_condition)
    
    # 2. 상위 20개 히트상품 추출
    return top_n_extractor(contribution_data, n=20)",,
[1] 상품,순위,상품별취소율,"취소율, 순위계산, 상위N개추출",상품별 취소율을 계산하고 순위를 매겨 상위 20개 추출,"def product_cancellation_rate_ranking(df, filter_condition=None):
    """"""상품별취소율""""""
    # 1. 상품별 취소율 계산
    cancel_rate_data = cancellation_rate(df, group_by='상품명', filter_condition=filter_condition)
    
    # 2. 순위 계산 (높은 취소율 순)
    ranked_data = ranking_calculator(cancel_rate_data, '취소율(%)', ascending=False)
    
    # 3. 상위 20개 추출
    return top_n_extractor(ranked_data, n=20)",,
[1] 상품,순위,상품별반품율,"반품률, 순위계산, 상위N개추출",상품별 반품률을 계산하고 순위를 매겨 상위 20개 추출,"def product_return_rate_ranking(df, filter_condition=None):
    """"""상품별반품율""""""
    # 1. 상품별 반품률 계산
    return_rate_data = return_rate(df, group_by='상품명', filter_condition=filter_condition)
    
    # 2. 순위 계산 (높은 반품률 순)
    ranked_data = ranking_calculator(return_rate_data, '반품률(%)', ascending=False)
    
    # 3. 상위 20개 추출
    return top_n_extractor(ranked_data, n=20)",,
[1] 상품,고급,상품매출성장률,"총매출액, 변동분석",상품별 매출액의 기간별 성장률 분석,"def product_revenue_growth_rate(current_df, previous_df, filter_condition=None):
    """"""상품매출성장률""""""
    # 기간별 상품 매출 변동률 분석
    growth_data = change_analyzer(
        current_df, previous_df, '매출액', 
        group_by='상품명', filter_condition=filter_condition
    )
    
    return growth_data.sort_values('변동률(%)', ascending=False)",,
[1] 상품,고급,상품매출순위변동,"총매출액, 순위계산, 변동분석",상품별 매출순위의 기간별 변동 분석,"def product_ranking_change(current_df, previous_df, filter_condition=None):
    """"""상품매출순위변동""""""
    # 1. 현재 기간 매출 순위 계산
    current_revenue = total_revenue(current_df, group_by='상품명', filter_condition=filter_condition)
    current_ranking = ranking_calculator(current_revenue, '매출액')
    
    # 2. 이전 기간 매출 순위 계산
    previous_revenue = total_revenue(previous_df, group_by='상품명', filter_condition=filter_condition)
    previous_ranking = ranking_calculator(previous_revenue, '매출액')
    
    # 3. 순위 변동 분석
    ranking_change = change_analyzer(
        current_ranking, previous_ranking, '순위',
        group_by='상품명', filter_condition=None
    )
    
    return ranking_change.sort_values('변동률(%)', ascending=False)",,
[1] 상품,비율,상품가격대별매출분포,"총매출액, 분포분석",상품 가격대별 매출액 분포 현황 분석,"def product_price_range_distribution(df, filter_condition=None):
    """"""상품가격대별매출분포""""""
    # 1. 상품별 매출액 계산
    revenue_data = total_revenue(df, group_by='상품명', filter_condition=filter_condition)
    
    # 2. 가격대별 분포 분석 (5개 구간)
    price_bins = ['저가', '중저가', '중간', '중고가', '고가']
    distribution_data = distribution_analyzer(
        revenue_data, '매출액', bins=5, labels=price_bins, filter_condition=None
    )
    
    return distribution_data",,
[1] 상품,비율,상품별클레임율,"취소율, 반품률, 지표결합계산, 순위계산, 상위N개추출",상품별 클레임율(취소+반품)을 계산하고 상위 20개 추출,"def product_claim_rate(df, filter_condition=None):
    """"""상품별클레임율""""""
    # 1. 상품별 취소율과 반품률 계산
    cancel_data = cancellation_rate(df, group_by='상품명', filter_condition=filter_condition)
    return_data = return_rate(df, group_by='상품명', filter_condition=filter_condition)
    
    # 2. 취소율과 반품률 결합하여 클레임율 계산
    combine_config = {
        'operation': 'add',
        'columns': ['취소율(%)', '반품률(%)']
    }
    
    # 데이터 병합
    merged_data = pd.merge(cancel_data, return_data, on='상품명', how='outer').fillna(0)
    
    # 지표 결합
    claim_data = metric_combiner(merged_data, combine_config)
    claim_data = claim_data.rename(columns={'결합지표': '클레임율(%)'})
    
    # 3. 순위 계산
    ranked_data = ranking_calculator(claim_data, '클레임율(%)', ascending=False)
    
    # 4. 상위 20개 추출
    return top_n_extractor(ranked_data, n=20)",,
[1] 상품,고급,상품별재구매기여도,"재구매율, 기여도계산, 상위N개추출",상품별 재구매 유도 기여도를 계산하여 상위 추출,"def product_repurchase_contribution(df, filter_condition=None):
    """"""상품별재구매기여도""""""
    # 1. 상품별 재구매율 계산
    repurchase_data = repurchase_rate(df, group_by='상품명', filter_condition=filter_condition)
    
    # 2. 재구매 기여도 계산
    contribution_data = contribution_calculator(repurchase_data, '재구매율(%)', group_by='상품명')
    
    # 3. 상위 기여도 상품들 추출
    return top_n_extractor(contribution_data, n=20)",,
[2] 업체,집계,업체별총매출액,총매출액,업체별 총매출액 집계,"def vendor_total_revenue(df, filter_condition=None):
    """"""업체별 총매출액""""""
    return total_revenue(df, group_by='업체명', filter_condition=filter_condition)",,
[2] 업체,집계,업체별총주문수,총주문건수,업체별 총주문건수 집계,"def vendor_total_orders(df, filter_condition=None):
    """"""업체별 총주문수""""""
    return total_orders(df, group_by='업체명', filter_condition=filter_condition)",,
[2] 업체,평균,업체별평균주문금액,평균주문금액,업체별 평균주문금액,"def vendor_average_order_value(df, filter_condition=None):
    """"""업체별 평균주문금액""""""
    return average_order_value(df, group_by='업체명', filter_condition=filter_condition)",,
[2] 업체,집계,업체별총수익액,총수익액,업체별 총수익액 집계,"def vendor_total_profit(df, filter_condition=None):
    """"""업체별 총수익액""""""
    return total_profit(df, group_by='업체명', filter_condition=filter_condition)",,
[2] 업체,집계,업체별총수량,총수량,업체별 총수량 집계,"def vendor_total_quantity(df, filter_condition=None):
    """"""업체별 총수량""""""
    return total_quantity(df, group_by='업체명', filter_condition=filter_condition)",,
[2] 업체,순위,업체별매출순위,"총매출액, 순위",업체별 매출액 기준 전체 순위,"def vendor_revenue_ranking(df, filter_condition=None):
    """"""업체별 전체매출순위""""""
    # 1. 업체별 매출액 계산
    revenue_data = total_revenue(df, group_by='업체명', filter_condition=filter_condition)
    
    # 2. 순위 계산
    ranked_data = ranking_calculator(revenue_data, '매출액')
    
    return ranked_data",,
[2] 업체,고급,업체별매출성장률(전기대비),"총매출액, 변동률",전기 대비 업체 매출 변동률,"def vendor_revenue_growth_qoq(current_df, previous_df, filter_condition=None):
    """"""매출성장률전기대비""""""
    # 전기 대비 업체 매출 변동률
    growth_data = change_analyzer(
        current_df, previous_df, '매출액',
        group_by='업체명', filter_condition=filter_condition
    )
    
    return growth_data.sort_values('변동률(%)', ascending=False)",,
[2] 업체,고급,업체매출성장률,"총매출액, 변동률",업체별 매출 성장률,"def vendor_revenue_growth_rate(current_df, previous_df, filter_condition=None):
    """"""업체매출성장률""""""
    # 업체별 매출 성장률
    growth_data = change_analyzer(
        current_df, previous_df, '매출액',
        group_by='업체명', filter_condition=filter_condition
    )
    
    return growth_data.sort_values('변동률(%)', ascending=False)",,
[2] 업체,고급,업체별매출순위변동,"총매출액, 순위, 변동률",업체별 매출순위 변동률,"def vendor_ranking_change(current_df, previous_df, filter_condition=None):
    """"""업체매출순위변동""""""
    # 1. 현재 기간 매출 순위
    current_revenue = total_revenue(current_df, group_by='업체명', filter_condition=filter_condition)
    current_ranking = ranking_calculator(current_revenue, '매출액')
    
    # 2. 이전 기간 매출 순위
    previous_revenue = total_revenue(previous_df, group_by='업체명', filter_condition=filter_condition)
    previous_ranking = ranking_calculator(previous_revenue, '매출액')
    
    # 3. 순위 변동 분석
    ranking_change = change_analyzer(
        current_ranking, previous_ranking, '순위',
        group_by='업체명', filter_condition=None
    )
    
    return ranking_change.sort_values('변동률(%)', ascending=False)",,
[2] 업체,비율,업체별평균마진율,"총수익액, 총매출액",업체별 평균 마진율 (수익률),"def vendor_average_margin_rate(df, filter_condition=None):
    """"""업체평균마진율""""""
    # 1. 업체별 총수익액과 총매출액 계산
    profit_data = total_profit(df, group_by='업체명', filter_condition=filter_condition)
    revenue_data = total_revenue(df, group_by='업체명', filter_condition=filter_condition)
    
    # 2. 데이터 병합
    merged_data = pd.merge(profit_data, revenue_data, on='업체명', how='inner')
    
    # 3. 마진율 계산
    merged_data['마진율(%)'] = (merged_data['수익액'] / merged_data['매출액'] * 100).round(2)
    
    return merged_data.sort_values('마진율(%)', ascending=False)",,
[2] 업체,순위,업체별마진순위,"수익률, 순위, 상위N개",업체별 마진율 기준 순위 (상위 추출),"def vendor_margin_ranking(df, filter_condition=None):
    """"""업체마진순위""""""
    # 1. 업체별 수익률 계산
    margin_data = profit_rate(df, group_by='업체명', filter_condition=filter_condition)
    
    # 2. 순위 계산
    ranked_data = ranking_calculator(margin_data, '수익률(%)')
    
    # 3. 상위 업체들 추출
    return top_n_extractor(ranked_data, n=50)",,
[2] 업체,비율,업체별취소율,취소율,업체별 취소율,"def vendor_cancellation_rate(df, filter_condition=None):
    """"""업체취소율""""""
    return cancellation_rate(df, group_by='업체명', filter_condition=filter_condition)",,
[2] 업체,비율,업체별반품율,반품률,업체별 반품률,"def vendor_return_rate(df, filter_condition=None):
    """"""업체반품율""""""
    return return_rate(df, group_by='업체명', filter_condition=filter_condition)",,
[2] 업체,비율,업체별교환율,교환율,업체별 교환율,"def vendor_exchange_rate(df, filter_condition=None):
    """"""업체교환율""""""
    return exchange_rate(df, group_by='업체명', filter_condition=filter_condition)",,
[2] 업체,비율,업체별클레임율,"취소율, 반품률, 교환율, 지표결합",업체별 종합 클레임율 (취소+반품+교환),"def vendor_claim_rate(df, filter_condition=None):
    """"""업체클레임율""""""
    # 1. 업체별 취소율, 반품률, 교환율 계산
    cancel_data = cancellation_rate(df, group_by='업체명', filter_condition=filter_condition)
    return_data = return_rate(df, group_by='업체명', filter_condition=filter_condition)
    exchange_data = exchange_rate(df, group_by='업체명', filter_condition=filter_condition)
    
    # 2. 데이터 병합
    merged_data = pd.merge(cancel_data, return_data, on='업체명', how='outer').fillna(0)
    merged_data = pd.merge(merged_data, exchange_data, on='업체명', how='outer').fillna(0)
    
    # 3. 취소율, 반품률, 교환율 결합하여 클레임율 계산
    combine_config = {
        'operation': 'add',
        'columns': ['취소율(%)', '반품률(%)', '교환율(%)']
    }
    
    claim_data = metric_combiner(merged_data, combine_config)
    claim_data = claim_data.rename(columns={'결합지표': '클레임율(%)'})
    
    return claim_data.sort_values('클레임율(%)', ascending=False)",,
[3] 고객,집계,총고객수,총고객수,고유구매자 수,"def customer_total_count(df, filter_condition=None):
    """"""총고객수""""""
    return total_customers(df, filter_condition=filter_condition)",,
[3] 고객,비율,재구매율,재구매율,2회 이상 구매 고객 비율,"def customer_repurchase_rate(df, filter_condition=None):
    """"""재구매율""""""
    return repurchase_rate(df, filter_condition=filter_condition)",,
[3] 고객,고급,상위10퍼고객매출비중,"총매출액, 총고객수",상위 10% 고객의 매출 기여도,"def top10_percent_customer_revenue_contribution(df, filter_condition=None):
    """"""상위10퍼고객매출비중""""""
    # 1. 고객별 매출액 계산
    customer_revenue = total_revenue(df, group_by='고객ID', filter_condition=filter_condition)
    
    # 2. 전체 고객 수의 10% 계산
    total_customers = len(customer_revenue)
    top_10_percent_count = max(1, int(total_customers * 0.1))
    
    # 3. 상위 10% 고객 추출
    top_customers = top_n_extractor(customer_revenue.sort_values('매출액', ascending=False), n=top_10_percent_count)
    
    # 4. 상위 10% 고객의 매출 기여도 계산
    contribution_data = contribution_calculator(df, '매출액', group_by='고객ID', filter_condition=filter_condition)
    top_contribution = contribution_data[contribution_data['고객ID'].isin(top_customers['고객ID'])]
    
    # 5. 상위 10% 고객의 총 기여도
    total_contribution = top_contribution['기여도(%)'].sum()
    
    return {
        '상위10퍼고객수': top_10_percent_count,
        '전체고객수': total_customers,
        '상위10퍼매출기여도(%)': round(total_contribution, 2),
        '상위고객목록': top_customers
    }",,
[3] 고객,비율,다중구매고객비율,추가필터적용,여러 상품 구매 고객 비율,"def multi_purchase_customer_ratio(df, filter_condition=None):
    """"""다중구매고객비율""""""
    # 여러 상품을 구매한 고객 비율 계산
    conditions_config = {
        'conditions': [
            {'column': '구매상품수', 'operator': '>', 'value': 1}
        ],
        'logic': 'AND'
    }
    
    # 고객별 구매 상품 수 계산 후 다중조건 적용
    customer_products = df.groupby('고객ID')['상품명'].nunique().reset_index()
    customer_products.columns = ['고객ID', '구매상품수']
    
    result = multi_condition_calculator(customer_products, conditions_config)
    
    return result",,
[3] 고객,평균,고객당평균구매상품수,"총상품수, 총고객수",고객별 평균 구매 상품수,"def average_products_per_customer(df, filter_condition=None):
    """"""고객당평균구매상품수""""""
    # 1. 고객별 구매 상품 수
    products_data = total_products(df, group_by='고객ID', filter_condition=filter_condition)
    
    # 2. 전체 고객 수
    customers_data = total_customers(df, filter_condition=filter_condition)
    
    # 3. 평균 계산
    if customers_data > 0:
        average_products = products_data['상품수'].mean().round(2)
    else:
        average_products = 0
    
    return {
        '전체고객수': customers_data,
        '총구매상품수': products_data['상품수'].sum(),
        '고객당평균구매상품수': average_products
    }",,
[3] 고객,비율,신규고객비율,추가필터적용,분석 기간 내 신규 고객 비율,"def new_customer_ratio(df, analysis_start_date, filter_condition=None):
    """"""신규고객비율""""""
    # 분석 기간 내 신규 고객 비율 계산
    df['주문일시'] = pd.to_datetime(df['주문일시'])
    
    # 각 고객의 첫 구매일 계산
    first_purchase = df.groupby('고객ID')['주문일시'].min().reset_index()
    first_purchase.columns = ['고객ID', '첫구매일']
    
    # 분석 기간 내 첫 구매 조건
    analysis_start = pd.to_datetime(analysis_start_date)
    first_purchase['신규고객여부'] = first_purchase['첫구매일'] >= analysis_start
    
    conditions_config = {
        'conditions': [
            {'column': '신규고객여부', 'operator': '==', 'value': True}
        ],
        'logic': 'AND'
    }
    
    result = multi_condition_calculator(first_purchase, conditions_config)
    
    return result",,
[3] 고객,비율,기존고객이탈률,추가필터적용,일정 기간 구매 중단 고객 비율,"def existing_customer_churn_rate(df, churn_days=90, filter_condition=None):
    """"""기존고객이탈률""""""
    # 고객 이탈률 분석
    churn_result = churn_analyzer(df, '고객ID', '주문일시', churn_days, filter_condition)
    
    return churn_result",,
[3] 고객,비율,재구매고객매출비중,"재구매율, 총매출액",재구매 고객의 매출 기여도,"def repurchase_customer_revenue_contribution(df, filter_condition=None):
    """"""재구매고객매출비중""""""
    # 1. 고객별 구매 횟수 계산
    customer_orders = df.groupby('고객ID').size().reset_index(name='구매횟수')
    repurchase_customers = customer_orders[customer_orders['구매횟수'] >= 2]['고객ID'].tolist()
    
    # 2. 재구매 고객들의 매출 기여도 계산
    repurchase_df = df[df['고객ID'].isin(repurchase_customers)]
    
    # 3. 기여도 계산
    contribution_data = contribution_calculator(df, '매출액', filter_condition=filter_condition)
    repurchase_contribution = contribution_calculator(repurchase_df, '매출액', filter_condition=filter_condition)
    
    # 4. 재구매 고객 매출 비중
    if contribution_data > 0:
        repurchase_ratio = (repurchase_contribution / contribution_data * 100).round(2)
    else:
        repurchase_ratio = 0
    
    return {
        '전체매출액': contribution_data,
        '재구매고객매출액': repurchase_contribution,
        '재구매고객매출비중(%)': repurchase_ratio,
        '재구매고객수': len(repurchase_customers)
    }",,
[3] 고객,고급,고객재구매횟수분포,추가필터적용,고객별 재구매 횟수 분포,"def customer_repurchase_count_distribution(df, filter_condition=None):
    """"""고객재구매횟수분포""""""
    # 1. 고객별 구매 횟수 계산
    customer_purchase_count = df.groupby('고객ID').size().reset_index(name='구매횟수')
    
    # 2. 구매 횟수 분포 분석 (구간: 1회, 2회, 3회, 4회, 5회 이상)
    bins = [0, 1, 2, 3, 4, float('inf')]
    labels = ['1회', '2회', '3회', '4회', '5회이상']
    
    distribution_result = distribution_analyzer(
        customer_purchase_count, '구매횟수', bins=bins, labels=labels, filter_condition=filter_condition
    )
    
    return distribution_result",,
[3] 고객,평균,고객평균LTV,"총매출액, 총고객수",고객별 평균 생애가치,"def customer_average_ltv(df, filter_condition=None):
    """"""고객평균LTV""""""
    # 1. 고객별 LTV 계산
    ltv_data = ltv_calculator(df, '고객ID', '매출액', '주문일시', filter_condition=filter_condition)
    
    # 2. 평균 LTV 계산
    average_current_ltv = ltv_data['현재LTV'].mean().round(0)
    average_predicted_ltv = ltv_data['예상LTV'].mean().round(0)
    
    # 3. LTV 분포 통계
    ltv_stats = {
        '전체고객수': len(ltv_data),
        '평균현재LTV': average_current_ltv,
        '평균예상LTV': average_predicted_ltv,
        '중간값현재LTV': ltv_data['현재LTV'].median().round(0),
        '중간값예상LTV': ltv_data['예상LTV'].median().round(0),
        '최대현재LTV': ltv_data['현재LTV'].max(),
        '최대예상LTV': ltv_data['예상LTV'].max()
    }
    
    return ltv_stats",,
[4] 채널,비율,채널별매출비중,"총매출액, 점유율",채널별 매출액 점유율 (전체 대비 비중),"def channel_revenue_share(df, filter_condition=None):
    """"""채널별매출비중""""""
    # 채널별 매출액 점유율 계산
    return market_share_calculator(df, '매출액', group_by='채널명', filter_condition=filter_condition)",,
[4] 채널,비율,채널별주문수비중,"총주문건수, 점유율",채널별 주문수 점유율 (전체 대비 비중),"def channel_order_share(df, filter_condition=None):
    """"""채널별주문수비중""""""
    # 채널별 주문수 점유율 계산
    return market_share_calculator(df, '주문건수', group_by='채널명', filter_condition=filter_condition)",,
[4] 채널,순위,채널별업체매출순위,"총매출액, 순위, 상위N개",채널 내 업체별 매출 순위 (채널별 분석),"def channel_vendor_revenue_ranking(df, channel_name, filter_condition=None):
    """"""채널별업체매출순위""""""
    # 1. 특정 채널 데이터 필터링
    channel_df = df[df['채널명'] == channel_name].copy()
    
    if filter_condition:
        channel_df = apply_filter(channel_df, filter_condition)
    
    # 2. 채널 내 업체별 매출액 계산
    vendor_revenue = total_revenue(channel_df, group_by='업체명')
    
    # 3. 순위 계산
    ranked_data = ranking_calculator(vendor_revenue, '매출액')
    
    # 4. 상위 업체들 추출
    return top_n_extractor(ranked_data, n=30)",,
[4] 채널,비율,채널별업체점유율,"총매출액, 점유율",채널 내 업체별 매출 점유율,"def channel_vendor_market_share(df, channel_name, filter_condition=None):
    """"""채널별업체점유율""""""
    # 1. 특정 채널 데이터 필터링
    channel_df = df[df['채널명'] == channel_name].copy()
    
    # 2. 채널 내 업체별 점유율 계산
    return market_share_calculator(channel_df, '매출액', group_by='업체명', filter_condition=filter_condition)",,
[4] 채널,고급,채널매출성장률,"총매출액, 변동률",채널별 매출액 성장률 (기간 대비),"def channel_revenue_growth_rate(current_df, previous_df, filter_condition=None):
    """"""채널매출성장률""""""
    # 채널별 매출액 성장률
    growth_data = change_analyzer(
        current_df, previous_df, '매출액',
        group_by='채널명', filter_condition=filter_condition
    )
    
    return growth_data.sort_values('변동률(%)', ascending=False)",,
[4] 채널,고급,채널주문수성장률,"총주문건수, 변동률",채널별 주문수 성장률 (기간 대비),"def channel_order_growth_rate(current_df, previous_df, filter_condition=None):
    """"""채널주문수성장률""""""
    # 채널별 주문수 성장률
    growth_data = change_analyzer(
        current_df, previous_df, '주문건수',
        group_by='채널명', filter_condition=filter_condition
    )
    
    return growth_data.sort_values('변동률(%)', ascending=False)",,
[4] 채널,고급,채널점유율추세,"총매출액, 점유율, 추세",채널 점유율의 시계열 변화 추세,"def channel_market_share_trend(df_list, filter_condition=None):
    """"""채널점유율추세""""""
    # 1. 각 기간별 채널 점유율 계산
    period_shares = []
    
    for i, df in enumerate(df_list):
        share_data = market_share_calculator(df, '매출액', group_by='채널명', filter_condition=filter_condition)
        share_data['기간'] = i + 1
        period_shares.append(share_data)
    
    # 2. 전체 추세 데이터 결합
    trend_data = pd.concat(period_shares, ignore_index=True)
    
    # 3. 채널별 점유율 추세 분석
    trend_result = []
    for channel in trend_data['채널명'].unique():
        channel_trend = trend_data[trend_data['채널명'] == channel].sort_values('기간')
        
        # 추세 분석
        trend_analysis = trend_analyzer([channel_trend], '점유율(%)', group_by='채널명')
        trend_analysis['채널명'] = channel
        trend_result.append(trend_analysis)
    
    return pd.concat(trend_result, ignore_index=True)",,
[4] 채널,고급,채널별매출순위변동,"총매출액, 순위, 변동률",채널간 매출 순위 변동률,"def channel_revenue_ranking_change(current_df, previous_df, filter_condition=None):
    """"""채널별매출순위변동""""""
    # 1. 현재 기간 채널별 매출 순위
    current_revenue = total_revenue(current_df, group_by='채널명', filter_condition=filter_condition)
    current_ranking = ranking_calculator(current_revenue, '매출액')
    
    # 2. 이전 기간 채널별 매출 순위
    previous_revenue = total_revenue(previous_df, group_by='채널명', filter_condition=filter_condition)
    previous_ranking = ranking_calculator(previous_revenue, '매출액')
    
    # 3. 순위 변동 분석
    ranking_change = change_analyzer(
        current_ranking, previous_ranking, '순위',
        group_by='채널명', filter_condition=None
    )
    
    return ranking_change.sort_values('변동률(%)', ascending=False)",,
[4] 채널,고급,채널내업체매출순위변동,"총매출액, 순위, 변동률",채널 내 업체별 매출 순위 변동률,"def channel_vendor_ranking_change(current_df, previous_df, channel_name, filter_condition=None):
    """"""채널내업체매출순위변동""""""
    # 1. 특정 채널 데이터만 필터링
    current_channel = current_df[current_df['채널명'] == channel_name].copy()
    previous_channel = previous_df[previous_df['채널명'] == channel_name].copy()
    
    # 2. 현재 기간 채널 내 업체별 매출 순위
    current_revenue = total_revenue(current_channel, group_by='업체명', filter_condition=filter_condition)
    current_ranking = ranking_calculator(current_revenue, '매출액')
    
    # 3. 이전 기간 채널 내 업체별 매출 순위
    previous_revenue = total_revenue(previous_channel, group_by='업체명', filter_condition=filter_condition)
    previous_ranking = ranking_calculator(previous_revenue, '매출액')
    
    # 4. 순위 변동 분석
    ranking_change = change_analyzer(
        current_ranking, previous_ranking, '순위',
        group_by='업체명', filter_condition=None
    )
    
    return ranking_change.sort_values('변동률(%)', ascending=False)",,
[4] 채널,순위,채널내상품매출순위,"총매출액, 순위, 상위N개",채널별 상품 매출 순위 (채널별 분석),"def channel_product_revenue_ranking(df, channel_name, filter_condition=None):
    """"""채널내상품매출순위""""""
    # 1. 특정 채널 데이터 필터링
    channel_df = df[df['채널명'] == channel_name].copy()
    
    # 2. 채널 내 상품별 매출액 계산
    product_revenue = total_revenue(channel_df, group_by='상품명', filter_condition=filter_condition)
    
    # 3. 순위 계산
    ranked_data = ranking_calculator(product_revenue, '매출액')
    
    # 4. 상위 상품들 추출
    return top_n_extractor(ranked_data, n=50)",,
[4] 채널,비율,채널별취소율,취소율,채널별 주문 취소율,"def channel_cancellation_rate(df, filter_condition=None):
    """"""채널별취소율""""""
    return cancellation_rate(df, group_by='채널명', filter_condition=filter_condition)",,
[4] 채널,비율,채널별반품율,반품률,채널별 상품 반품률,"def channel_return_rate(df, filter_condition=None):
    """"""채널별반품율""""""
    return return_rate(df, group_by='채널명', filter_condition=filter_condition)",,
[4] 채널,비율,채널별클레임율,"취소율, 반품률, 지표결합",채널별 종합 클레임율 (취소+반품),"def channel_claim_rate(df, filter_condition=None):
    """"""채널별클레임율""""""
    # 1. 채널별 취소율과 반품률 계산
    cancel_data = cancellation_rate(df, group_by='채널명', filter_condition=filter_condition)
    return_data = return_rate(df, group_by='채널명', filter_condition=filter_condition)
    
    # 2. 데이터 병합
    merged_data = pd.merge(cancel_data, return_data, on='채널명', how='outer').fillna(0)
    
    # 3. 취소율과 반품률 결합하여 클레임율 계산
    combine_config = {
        'operation': 'add',
        'columns': ['취소율(%)', '반품률(%)']
    }
    
    claim_data = metric_combiner(merged_data, combine_config)
    claim_data = claim_data.rename(columns={'결합지표': '클레임율(%)'})
    
    return claim_data.sort_values('클레임율(%)', ascending=False)",,
[4] 채널,고급,채널딜기여도,"총매출액, 기여도",특정 채널의 딜/프로모션 매출 기여도,"def channel_deal_contribution(df, deal_channel_name, filter_condition=None):
    """"""채널딜기여도""""""
    # 1. 특정 딜 채널의 매출 기여도 계산
    deal_contribution = contribution_calculator(df, '매출액', group_by='채널명', filter_condition=filter_condition)
    
    # 2. 특정 채널의 기여도 추출
    channel_contribution = deal_contribution[deal_contribution['채널명'] == deal_channel_name]
    
    if len(channel_contribution) > 0:
        return {
            '채널명': deal_channel_name,
            '매출액': channel_contribution['매출액'].iloc[0],
            '기여도(%)': channel_contribution['기여도(%)'].iloc[0],
            '누적기여도(%)': channel_contribution['누적기여도(%)'].iloc[0]
        }
    else:
        return {
            '채널명': deal_channel_name,
            '매출액': 0,
            '기여도(%)': 0,
            '누적기여도(%)': 0
        }",,
[5] 카테고리,집계,카테고리중분류별매출,"총매출액, 카테고리분류",중분류별 매출액 집계,"def category_mid_revenue(df, filter_condition=None):
    """"""카테고리중분류별매출""""""
    # 1. 중분류 카테고리 분류
    df_mid = category_classifier(df, category_type='중분류', filter_condition=filter_condition)
    
    # 2. 중분류별 매출액 집계
    return total_revenue(df_mid, group_by='중분류명')",,
[5] 카테고리,순위,카테고리중분류별업체매출순위,"총매출액, 순위, 상위N개, 카테고리분류",중분류 내 업체별 매출 순위,"def category_mid_vendor_revenue_ranking(df, mid_category_name, filter_condition=None):
    """"""카테고리중분류별업체매출순위""""""
    # 1. 중분류 카테고리 분류
    df_mid = category_classifier(df, category_type='중분류', filter_condition=filter_condition)
    
    # 2. 특정 중분류 필터링
    df_filtered = df_mid[df_mid['중분류명'] == mid_category_name]
    
    # 3. 업체별 매출액 계산 및 순위
    vendor_revenue = total_revenue(df_filtered, group_by='업체명')
    ranked_data = ranking_calculator(vendor_revenue, '매출액')
    
    # 4. 상위 업체들 추출
    return top_n_extractor(ranked_data, n=30)",,설명
[5] 카테고리,순위,카테고리중분류별상품매출순위,"총매출액, 순위, 상위N개, 카테고리분류",중분류 내 상품별 매출 순위,"def category_mid_product_revenue_ranking(df, mid_category_name, filter_condition=None):
    """"""카테고리중분류별상품매출순위""""""
    # 1. 중분류 카테고리 분류
    df_mid = category_classifier(df, category_type='중분류', filter_condition=filter_condition)
    
    # 2. 특정 중분류 필터링
    df_filtered = df_mid[df_mid['중분류명'] == mid_category_name]
    
    # 3. 상품별 매출액 계산 및 순위
    product_revenue = total_revenue(df_filtered, group_by='상품명')
    ranked_data = ranking_calculator(product_revenue, '매출액')
    
    # 4. 상위 상품들 추출
    return top_n_extractor(ranked_data, n=50)",,채널별 매출액 점유율 (전체 대비 비중)
[5] 카테고리,비율,카테고리중분류별업체시장점유율,"총매출액, 점유율, 카테고리분류",중분류 내 업체별 점유율,"def category_mid_vendor_market_share(df, mid_category_name, filter_condition=None):
    """"""카테고리중분류별업체시장점유율""""""
    # 1. 중분류 카테고리 분류
    df_mid = category_classifier(df, category_type='중분류', filter_condition=filter_condition)
    
    # 2. 특정 중분류 필터링
    df_filtered = df_mid[df_mid['중분류명'] == mid_category_name]
    
    # 3. 중분류 내 업체별 점유율 계산
    return market_share_calculator(df_filtered, '매출액', group_by='업체명')",,채널별 주문수 점유율 (전체 대비 비중)
[5] 카테고리,집계,카테고리중분류별주문수,"총주문건수, 카테고리분류",중분류별 주문건수 집계,"def category_mid_orders(df, filter_condition=None):
    """"""카테고리중분류별주문수""""""
    # 1. 중분류 카테고리 분류
    df_mid = category_classifier(df, category_type='중분류', filter_condition=filter_condition)
    
    # 2. 중분류별 주문건수 집계
    return total_orders(df_mid, group_by='중분류명')",,채널 내 업체별 매출 순위 (채널별 분석)
[5] 카테고리,평균,카테고리중분류별평균주문금액,"평균주문금액, 카테고리분류",중분류별 평균주문금액,"def category_mid_avg_order_value(df, filter_condition=None):
    """"""카테고리중분류별평균주문금액""""""
    # 1. 중분류 카테고리 분류
    df_mid = category_classifier(df, category_type='중분류', filter_condition=filter_condition)
    
    # 2. 중분류별 평균주문금액 계산
    return average_order_value(df_mid, group_by='중분류명')",,채널 내 업체별 매출 점유율
[5] 카테고리,고급,카테고리중분류별매출순위변동,"총매출액, 순위, 변동률, 카테고리분류",중분류별 매출 순위 변동,"def category_mid_revenue_ranking_change(current_df, previous_df, filter_condition=None):
    """"""카테고리중분류별매출순위변동""""""
    # 1. 현재 기간 중분류별 매출 순위
    current_mid = category_classifier(current_df, category_type='중분류', filter_condition=filter_condition)
    current_revenue = total_revenue(current_mid, group_by='중분류명')
    current_ranking = ranking_calculator(current_revenue, '매출액')
    
    # 2. 이전 기간 중분류별 매출 순위
    previous_mid = category_classifier(previous_df, category_type='중분류', filter_condition=filter_condition)
    previous_revenue = total_revenue(previous_mid, group_by='중분류명')
    previous_ranking = ranking_calculator(previous_revenue, '매출액')
    
    # 3. 순위 변동 분석
    ranking_change = change_analyzer(
        current_ranking, previous_ranking, '순위',
        group_by='중분류명', filter_condition=None
    )
    
    return ranking_change.sort_values('변동률(%)', ascending=False)",,채널별 매출액 성장률 (기간 대비)
[5] 카테고리,비율,카테고리중분류별점유율,"총매출액, 점유율, 카테고리분류",중분류별 매출 점유율,"def category_mid_market_share(df, filter_condition=None):
    """"""카테고리중분류별점유율""""""
    # 1. 중분류 카테고리 분류
    df_mid = category_classifier(df, category_type='중분류', filter_condition=filter_condition)
    
    # 2. 중분류별 매출 점유율 계산
    return market_share_calculator(df_mid, '매출액', group_by='중분류명')",,채널별 주문수 성장률 (기간 대비)
[5] 카테고리,고급,카테고리중분류별점유율추세,"총매출액, 점유율, 추세, 카테고리분류",중분류별 점유율 시계열 추세,"def category_mid_market_share_trend(df_list, filter_condition=None):
    """"""카테고리중분류별점유율추세""""""
    # 1. 각 기간별 중분류 점유율 계산
    period_shares = []
    
    for i, df in enumerate(df_list):
        df_mid = category_classifier(df, category_type='중분류', filter_condition=filter_condition)
        share_data = market_share_calculator(df_mid, '매출액', group_by='중분류명')
        share_data['기간'] = i + 1
        period_shares.append(share_data)
    
    # 2. 전체 추세 데이터 결합
    trend_data = pd.concat(period_shares, ignore_index=True)
    
    # 3. 중분류별 점유율 추세 분석
    trend_result = []
    for category in trend_data['중분류명'].unique():
        category_trend = trend_data[trend_data['중분류명'] == category].sort_values('기간')
        
        if len(category_trend) > 1:
            x = category_trend['기간'].values
            y = category_trend['점유율(%)'].values
            slope = np.polyfit(x, y, 1)[0]
            trend_direction = '증가' if slope > 0 else '감소' if slope < 0 else '횡보'
        else:
            slope = 0
            trend_direction = '데이터부족'
        
        trend_result.append({
            '중분류명': category,
            '추세기울기': round(slope, 2),
            '추세방향': trend_direction,
            '시작점유율': y[0] if len(y) > 0 else 0,
            '종료점유율': y[-1] if len(y) > 0 else 0
        })
    
    return pd.DataFrame(trend_result).sort_values('추세기울기', ascending=False)",,채널 점유율의 시계열 변화 추세
[5] 카테고리,순위,카테고리중분류Top5,"총매출액, 상위N개, 카테고리분류",상위 5개 중분류 추출,"def category_mid_top5(df, filter_condition=None):
    """"""카테고리중분류Top5""""""
    # 1. 중분류별 매출액 계산
    mid_revenue = category_mid_revenue(df, filter_condition=filter_condition)
    
    # 2. 매출액 기준 정렬 후 상위 5개 추출
    return top_n_extractor(mid_revenue.sort_values('매출액', ascending=False), n=5)",,채널간 매출 순위 변동률
[5] 카테고리,고급,카테고리중분류Top5성장률,"총매출액, 상위N개, 변동률, 카테고리분류",상위 5개 중분류의 성장률,"def category_mid_top5_growth_rate(current_df, previous_df, filter_condition=None):
    """"""카테고리중분류Top5성장률""""""
    # 1. 상위 5개 중분류 선정 (현재 기간 기준)
    top5_categories = category_mid_top5(current_df, filter_condition=filter_condition)
    top5_names = top5_categories['중분류명'].tolist()
    
    # 2. 현재/이전 기간 중분류 데이터
    current_mid = category_classifier(current_df, category_type='중분류', filter_condition=filter_condition)
    previous_mid = category_classifier(previous_df, category_type='중분류', filter_condition=filter_condition)
    
    # 3. 성장률 계산
    growth_data = change_analyzer(
        current_mid, previous_mid, '매출액',
        group_by='중분류명', filter_condition=filter_condition
    )
    
    # 4. 상위 5개만 필터링
    return growth_data[growth_data['중분류명'].isin(top5_names)].sort_values('변동률(%)', ascending=False)",,채널 내 업체별 매출 순위 변동률
[5] 카테고리,집계,카테고리소분류별매출,"총매출액, 카테고리분류",소분류별 매출액 집계,"def category_sub_revenue(df, filter_condition=None):
    """"""카테고리소분류별매출""""""
    # 1. 소분류 카테고리 분류
    df_sub = category_classifier(df, category_type='소분류', filter_condition=filter_condition)
    
    # 2. 소분류별 매출액 집계
    return total_revenue(df_sub, group_by='소분류명')",,채널별 상품 매출 순위 (채널별 분석)
[5] 카테고리,순위,카테고리소분류별업체매출순위,"총매출액, 순위, 상위N개, 카테고리분류",소분류 내 업체별 매출 순위,"def category_sub_vendor_revenue_ranking(df, sub_category_name, filter_condition=None):
    """"""카테고리소분류별업체매출순위""""""
    # 1. 소분류 카테고리 분류
    df_sub = category_classifier(df, category_type='소분류', filter_condition=filter_condition)
    
    # 2. 특정 소분류 필터링
    df_filtered = df_sub[df_sub['소분류명'] == sub_category_name]
    
    # 3. 업체별 매출액 계산 및 순위
    vendor_revenue = total_revenue(df_filtered, group_by='업체명')
    ranked_data = ranking_calculator(vendor_revenue, '매출액')
    
    # 4. 상위 업체들 추출
    return top_n_extractor(ranked_data, n=30)",,채널별 주문 취소율
[5] 카테고리,순위,카테고리소분류별상품매출순위,"총매출액, 순위, 상위N개, 카테고리분류",소분류 내 상품별 매출 순위,"def category_sub_product_revenue_ranking(df, sub_category_name, filter_condition=None):
    """"""카테고리소분류별상품매출순위""""""
    # 1. 소분류 카테고리 분류
    df_sub = category_classifier(df, category_type='소분류', filter_condition=filter_condition)
    
    # 2. 특정 소분류 필터링
    df_filtered = df_sub[df_sub['소분류명'] == sub_category_name]
    
    # 3. 상품별 매출액 계산 및 순위
    product_revenue = total_revenue(df_filtered, group_by='상품명')
    ranked_data = ranking_calculator(product_revenue, '매출액')
    
    # 4. 상위 상품들 추출
    return top_n_extractor(ranked_data, n=50)",,채널별 상품 반품률
[5] 카테고리,비율,카테고리소분류별업체시장점유율,"총매출액, 점유율, 카테고리분류",소분류 내 업체별 점유율,"def category_sub_vendor_market_share(df, sub_category_name, filter_condition=None):
    """"""카테고리소분류별업체시장점유율""""""
    # 1. 소분류 카테고리 분류
    df_sub = category_classifier(df, category_type='소분류', filter_condition=filter_condition)
    
    # 2. 특정 소분류 필터링
    df_filtered = df_sub[df_sub['소분류명'] == sub_category_name]
    
    # 3. 소분류 내 업체별 점유율 계산
    return market_share_calculator(df_filtered, '매출액', group_by='업체명')",,채널별 종합 클레임율 (취소+반품)
[5] 카테고리,집계,카테고리소분류별주문수,"총주문건수, 카테고리분류",소분류별 주문건수 집계,"def category_sub_orders(df, filter_condition=None):
    """"""카테고리소분류별주문수""""""
    # 1. 소분류 카테고리 분류
    df_sub = category_classifier(df, category_type='소분류', filter_condition=filter_condition)
    
    # 2. 소분류별 주문건수 집계
    return total_orders(df_sub, group_by='소분류명')",,특정 채널의 딜/프로모션 매출 기여도
[5] 카테고리,평균,카테고리소분류별평균주문금액,"평균주문금액, 카테고리분류",소분류별 평균주문금액,"def category_sub_avg_order_value(df, filter_condition=None):
    """"""카테고리소분류별평균주문금액""""""
    # 1. 소분류 카테고리 분류
    df_sub = category_classifier(df, category_type='소분류', filter_condition=filter_condition)
    
    # 2. 소분류별 평균주문금액 계산
    return average_order_value(df_sub, group_by='소분류명')",,
[5] 카테고리,고급,카테고리소분류별매출순위변동,"총매출액, 순위, 변동률, 카테고리분류",소분류별 매출 순위 변동,"def category_sub_revenue_ranking_change(current_df, previous_df, filter_condition=None):
    """"""카테고리소분류별매출순위변동""""""
    # 1. 현재 기간 소분류별 매출 순위
    current_sub = category_classifier(current_df, category_type='소분류', filter_condition=filter_condition)
    current_revenue = total_revenue(current_sub, group_by='소분류명')
    current_ranking = ranking_calculator(current_revenue, '매출액')
    
    # 2. 이전 기간 소분류별 매출 순위
    previous_sub = category_classifier(previous_df, category_type='소분류', filter_condition=filter_condition)
    previous_revenue = total_revenue(previous_sub, group_by='소분류명')
    previous_ranking = ranking_calculator(previous_revenue, '매출액')
    
    # 3. 순위 변동 분석
    ranking_change = change_analyzer(
        current_ranking, previous_ranking, '순위',
        group_by='소분류명', filter_condition=None
    )
    
    return ranking_change.sort_values('변동률(%)', ascending=False)",,
[5] 카테고리,비율,카테고리소분류별점유율,"총매출액, 점유율, 카테고리분류",소분류별 매출 점유율,"def category_sub_market_share(df, filter_condition=None):
    """"""카테고리소분류별점유율""""""
    # 1. 소분류 카테고리 분류
    df_sub = category_classifier(df, category_type='소분류', filter_condition=filter_condition)
    
    # 2. 소분류별 매출 점유율 계산
    return market_share_calculator(df_sub, '매출액', group_by='소분류명')",,
[5] 카테고리,고급,카테고리소분류별점유율추세,"총매출액, 점유율, 추세, 카테고리분류",소분류별 점유율 시계열 추세,"def category_sub_market_share_trend(df_list, filter_condition=None):
    """"""카테고리소분류별점유율추세""""""
    # 1. 각 기간별 소분류 점유율 계산
    period_shares = []
    
    for i, df in enumerate(df_list):
        df_sub = category_classifier(df, category_type='소분류', filter_condition=filter_condition)
        share_data = market_share_calculator(df_sub, '매출액', group_by='소분류명')
        share_data['기간'] = i + 1
        period_shares.append(share_data)
    
    # 2. 전체 추세 데이터 결합
    trend_data = pd.concat(period_shares, ignore_index=True)
    
    # 3. 소분류별 점유율 추세 분석
    trend_result = []
    for category in trend_data['소분류명'].unique():
        category_trend = trend_data[trend_data['소분류명'] == category].sort_values('기간')
        
        if len(category_trend) > 1:
            x = category_trend['기간'].values
            y = category_trend['점유율(%)'].values
            slope = np.polyfit(x, y, 1)[0]
            trend_direction = '증가' if slope > 0 else '감소' if slope < 0 else '횡보'
        else:
            slope = 0
            trend_direction = '데이터부족'
        
        trend_result.append({
            '소분류명': category,
            '추세기울기': round(slope, 2),
            '추세방향': trend_direction,
            '시작점유율': y[0] if len(y) > 0 else 0,
            '종료점유율': y[-1] if len(y) > 0 else 0
        })
    
    return pd.DataFrame(trend_result).sort_values('추세기울기', ascending=False)",,
[5] 카테고리,순위,카테고리소분류Top5,"총매출액, 상위N개, 카테고리분류",상위 5개 소분류 추출,"def category_sub_top5(df, filter_condition=None):
    """"""카테고리소분류Top5""""""
    # 1. 소분류별 매출액 계산
    sub_revenue = category_sub_revenue(df, filter_condition=filter_condition)
    
    # 2. 매출액 기준 정렬 후 상위 5개 추출
    return top_n_extractor(sub_revenue.sort_values('매출액', ascending=False), n=5)",,
[5] 카테고리,고급,카테고리소분류Top5성장률,"총매출액, 상위N개, 변동률, 카테고리분류",상위 5개 소분류의 성장률,"def category_sub_top5_growth_rate(current_df, previous_df, filter_condition=None):
    """"""카테고리소분류Top5성장률""""""
    # 1. 상위 5개 소분류 선정 (현재 기간 기준)
    top5_categories = category_sub_top5(current_df, filter_condition=filter_condition)
    top5_names = top5_categories['소분류명'].tolist()
    
    # 2. 현재/이전 기간 소분류 데이터
    current_sub = category_classifier(current_df, category_type='소분류', filter_condition=filter_condition)
    previous_sub = category_classifier(previous_df, category_type='소분류', filter_condition=filter_condition)
    
    # 3. 성장률 계산
    growth_data = change_analyzer(
        current_sub, previous_sub, '매출액',
        group_by='소분류명', filter_condition=filter_condition
    )
    
    # 4. 상위 5개만 필터링
    return growth_data[growth_data['소분류명'].isin(top5_names)].sort_values('변동률(%)', ascending=False)",,
[6] 트렌드,고급,트렌드일자별매출추이,"총매출액, 시계열추이",일자별 매출액 시계열 추이 분석,"def trend_daily_revenue(df, filter_condition=None):
    """"""트렌드일자별매출추이""""""
    return time_series_trend(df, '주문일시', '매출액', period_type='daily', filter_condition=filter_condition)",,
[6] 트렌드,고급,트렌드일자별주문수추이,"총주문건수, 시계열추이",일자별 주문수 시계열 추이 분석,"def trend_daily_orders(df, filter_condition=None):
    """"""트렌드일자별주문수추이""""""
    return time_series_trend(df, '주문일시', '주문건수', period_type='daily', filter_condition=filter_condition)",,
[6] 트렌드,고급,트렌드주차별매출추이,"총매출액, 시계열추이",주차별 매출액 시계열 추이 분석,"def trend_weekly_revenue(df, filter_condition=None):
    """"""트렌드주차별매출추이""""""
    return time_series_trend(df, '주문일시', '매출액', period_type='weekly', filter_condition=filter_condition)",,
[6] 트렌드,고급,트렌드매출성장률2주,"총매출액, 변동률",2주 단위 매출 성장률,"def trend_revenue_growth_2weeks(df, filter_condition=None):
    """"""트렌드매출성장률2주""""""
    # 1. 주차별 매출 데이터 생성
    weekly_data = time_series_trend(df, '주문일시', '매출액', period_type='weekly', filter_condition=filter_condition)
    
    # 2. 주차를 datetime으로 변환하여 2주 단위로 그룹핑
    weekly_data['주차_datetime'] = pd.to_datetime(weekly_data['기간'] + '-1', format='%Y-W%W-%w')
    weekly_data['2주그룹'] = ((weekly_data['주차_datetime'] - weekly_data['주차_datetime'].min()).dt.days // 14)
    
    # 3. 2주 단위 집계
    biweekly_data = weekly_data.groupby('2주그룹')['매출액'].sum().reset_index()
    biweekly_data['2주차기간'] = biweekly_data['2주그룹'] + 1
    
    # 4. 전 2주차 대비 성장률 계산
    biweekly_data['이전2주매출'] = biweekly_data['매출액'].shift(1)
    biweekly_data['성장률(%)'] = biweekly_data.apply(
        lambda row: 0.0 if pd.isna(row['이전2주매출']) or row['이전2주매출'] == 0
        else ((row['매출액'] - row['이전2주매출']) / row['이전2주매출'] * 100),
        axis=1
    ).round(2)
    
    return biweekly_data[['2주차기간', '매출액', '이전2주매출', '성장률(%)']].dropna()",,
[6] 트렌드,고급,트렌드시간대별매출패턴,"총매출액, 패턴분석",시간대별 매출 패턴 분석,"def trend_hourly_revenue_pattern(df, filter_condition=None):
    """"""트렌드시간대별매출패턴""""""
    return pattern_analyzer(df, '주문일시', '매출액', pattern_type='hourly', filter_condition=filter_condition)",,
[6] 트렌드,고급,트렌드시간대별주문수패턴,"총주문건수, 패턴분석",시간대별 주문수 패턴 분석,"def trend_hourly_order_pattern(df, filter_condition=None):
    """"""트렌드시간대별주문수패턴""""""
    return pattern_analyzer(df, '주문일시', '주문건수', pattern_type='hourly', filter_condition=filter_condition)",,
[6] 트렌드,고급,트렌드피크시간대Top3,"총매출액, 상위N개, 피크검출",매출 피크 시간대 상위 3개 검출,"def trend_peak_hours_top3(df, filter_condition=None):
    """"""트렌드피크시간대Top3""""""
    # 1. 시간대별 매출 패턴 계산
    hourly_pattern = pattern_analyzer(df, '주문일시', '매출액', pattern_type='hourly', filter_condition=filter_condition)
    
    # 2. 상위 3개 피크 시간대 검출
    return peak_detector(hourly_pattern, '합계', peak_type='max', top_n=3)",,
[6] 트렌드,고급,트렌드요일별매출패턴,"총매출액, 패턴분석",요일별 매출 패턴 분석,"def trend_weekday_revenue_pattern(df, filter_condition=None):
    """"""트렌드요일별매출패턴""""""
    return pattern_analyzer(df, '주문일시', '매출액', pattern_type='weekday', filter_condition=filter_condition)",,
[6] 트렌드,고급,트렌드요일패턴스코어,"총매출액, 패턴분석, 스코어계산",요일별 매출 패턴 강도 스코어,"def trend_weekday_pattern_score(df, filter_condition=None):
    """"""트렌드요일패턴스코어""""""
    # 1. 요일별 매출 패턴 계산
    weekday_pattern = pattern_analyzer(df, '주문일시', '매출액', pattern_type='weekday', filter_condition=filter_condition)
    
    # 2. 패턴 강도 스코어 계산
    score_config = {
        'type': 'pattern_strength',
        'metric_column': '평균',
        'group_column': '요일',
        'weight_factors': {'consistency': 0.6, 'magnitude': 0.4}
    }
    
    return score_calculator(weekday_pattern, score_config)",,
[6] 트렌드,고급,트렌드채널별매출추이,"총매출액, 시계열추이",채널별 매출 시계열 추이 분석,"def trend_channel_revenue(df, filter_condition=None):
    """"""트렌드채널별매출추이""""""
    return time_series_trend(df, '주문일시', '매출액', period_type='daily', group_by='채널명', filter_condition=filter_condition)",,
[6] 트렌드,고급,트렌드중분류별매출추이Top5,"총매출액, 상위N개, 시계열추이, 카테고리분류",상위 5개 중분류의 매출 추이,"def trend_mid_category_revenue_top5(df, filter_condition=None):
    """"""트렌드중분류별매출추이Top5""""""
    # 1. 중분류 카테고리 분류
    df_mid = category_classifier(df, category_type='중분류', filter_condition=filter_condition)
    
    # 2. 상위 5개 중분류 선정
    top5_categories = category_mid_top5(df_mid)
    top5_names = top5_categories['중분류명'].tolist()
    
    # 3. 상위 5개 중분류만 필터링
    df_top5 = df_mid[df_mid['중분류명'].isin(top5_names)]
    
    # 4. 일자별 매출 추이 계산
    return time_series_trend(df_top5, '주문일시', '매출액', period_type='daily', group_by='중분류명')",,